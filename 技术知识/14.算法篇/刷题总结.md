[TOC]

# 字符串

## 最长公共子序列

题目：https://leetcode-cn.com/problems/longest-common-subsequence/

类似题目：[公共祖先](# 公共祖先，最低共同父节点 )

>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
>
>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
>
>若这两个字符串没有公共子序列，则返回 0。
>
>**示例 1:**
>
>```
>输入：text1 = "abcde", text2 = "ace" 
>输出：3  
>解释：最长公共子序列是 "ace"，它的长度为 3。
>```
>
>**示例 2:**
>
>```
>输入：text1 = "abc", text2 = "abc"
>输出：3
>解释：最长公共子序列是 "abc"，它的长度为 3。
>```
>
>**示例 3:**
>
>```
>输入：text1 = "abc", text2 = "def"
>输出：0
>解释：两个字符串没有公共子序列，返回 0。
>```
>
>**提示:**
>
>1 <= text1.length <= 1000
>1 <= text2.length <= 1000
>输入的字符串只含有小写英文字符。

solution：

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        int table[m+1][n+1];//table[ i ][ j ]为字符串A的第一个字符到第 i 个字符串和字符串B的第一个字符串到第 j 个字符串的最长公共子序列
        for(int i=0; i<= m; i++){
            table[i][0] = 0;
        }
        for(int i=0; i<=n; i++) {
            table[0][i] = 0;
        }
        for(int i=1; i<=m; i++) {
            for(int j=1; j<=n; j++) {
                if(text1[i-1] == text2[j-1]) {
                    table[i][j] = table[i-1][j-1]+1;
                } else{
                    table[i][j] = max(table[i][j-1], table[i-1][j]);
                }
            }
        }
        return table[m][n];
    }
};
```

分析：

>   table\[i][j][为字符串A的第一个字符到第 i 个字符串和字符串B的第一个字符串到第 j 个字符串的最长公共子序列
>
>   当我们要求table\[i][j]，我们要先判断A[i]和B[j]是否相同，
>    如果相同他就是table\[i-1][j-1] + 1，相当于在两个字符串都去掉一个字符时的最长公共字串再加 1；
>    否则最长公共字串取table\[ i ][ j - 1 ] 和table\[ i - 1 ][ j ] 中大者。
>   
>   

## 最长公共子串

题目：

(dp)子串是要求更严格的一种子序列，要求在母串中连续地出现。

> Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
>
> Input:
> A: "12321"
> B: "32147"
> Output: 3
> Explanation:
> The repeated subarray with maximum length is [3, 2, 1].

solution:

```c++
    class LongestSubstring {
    public:
        int findLongest(string A, int n, string B, int m) {
            int dp[1000][1000] = {0};//必须清零
            int max_len = 0;
            for(int i = 0;i < n;i++) {
                for(int j = 0;j < m;j++) {
                    if(A[i] == B[j]) {
                        if(i >0 && j>0) {
                            dp[i][j] = dp[i-1][j-1] +1;
                        }
                        else {
                            dp[i][j] = 1; // i= j= 0  的时候，不能使用上面那个公式，所以要单独写
                        }
                    }
                    if(max_len < dp[i][j]) {
                        max_len = dp[i][j];
                    }
                }
            }
            return max_len ;
        }
    };
```

分析：

* dp\[i][j]表示取到A[i]和取到B[j]时的最大连续子串长度,如果A[i]等于B[j]，则dp\[i-1][j-1]等于取到A1[i-1]和取到B[j-1]时的最大连续子串长度加1，即dp\[i][j]=dp\[i-1][j-1]+1。
* 所以转换方程为当A[i] = B[j]则dp\[i][j]=dp\[i-1][j-1]+1， 否则dp\[i][j]=0；
* 因为最大长度不一定用到最后的字符，所以需要有个变量max_len记录最长的公共子字符串。

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/动态规划.png" alt="动态规划" style="zoom:30%;" />

## 最长公共前缀

题目：https://leetcode-cn.com/problems/longest-common-prefix/

>编写一个函数来查找字符串数组中的最长公共前缀。
>
>如果不存在公共前缀，返回空字符串 ""。
>
>示例 1:
>
>```
>输入: ["flower","flow","flight"]
>输出: "fl"
>```
>
>示例 2:
>
>```
>输入: ["dog","racecar","car"]
>输出: ""
>解释: 输入不存在公共前缀。
>```

solution:

```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (!strs.size()) {
            return "";
        }
        int minLength = min_element(strs.begin(), strs.end(), [](const string& s, const string& t) {return s.size() < t.size();})->size();
        int low = 0, high = minLength;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (isCommonPrefix(strs, mid)) {
                low = mid;
            }
            else {
                high = mid - 1;
            }
        }
        return strs[0].substr(0, low);
    }

    bool isCommonPrefix(const vector<string>& strs, int length) {
        string str0 = strs[0].substr(0, length);
        int count = strs.size();
        for (int i = 1; i < count; ++i) {
            string str = strs[i];
            for (int j = 0; j < length; ++j) {
                if (str0[j] != str[j]) {
                    return false;
                }
            }
        }
        return true;
    }
};


```

分析：

* 这个题可以用横向扫描，也可以用纵向扫描，但是时间复杂度都是时间复杂度：$$O(mn)$$，其中 m是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。

* 二分法：时间复杂度：$$O(mn \log m)$$，其中 m是字符串数组中的字符串的最小长度，n是字符串的数量。二分查找的迭代执行次数是 $$O(\log m)$$，每次迭代最多需要比较 $$mn$$ 个字符，因此总时间复杂度是 $$O(mn \log m)$$

* 可以利用**字典树**实现。

  ```C++
  牛X解法：
  class Solution {
  public:
      string longestCommonPrefix(vector<string>& strs) {
          string res = strs.empty() ? "" : strs[0]; 
          for (string s : strs) 
              while (s.find(res) != 0) {
                res = res.substr(0, res.length() - 1);
              }
          return res;
      }
  };
  ```

  * 巧妙利用了C++字符串find返回子串的第一个字符出现的位置。

## 括号有效性

题目：https://leetcode-cn.com/problems/valid-parentheses/

>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
>有效字符串需满足：
>
>左括号必须用相同类型的右括号闭合。
>左括号必须以正确的顺序闭合。
>注意空字符串可被认为是有效字符串。
>
>**示例 1:**
>
>```
>输入: "()"
>输出: true
>
>```
>
>**示例 2:**
>
>```
>输入: "()[]{}"
>输出: true
>```
>
>**示例 3:**
>
>```
>输入: "(]"
>输出: false
>```
>
>**示例 4:**
>
>```
>输入: "([)]"
>输出: false
>```
>
>**示例 5:**
>
>```
>输入: "{[]}"
>输出: true
>```

solution:

```c++
    class Solution {
    public:
        bool check(char c1, char c2) {
            switch(c1) {
                case '}':
                    return c2 == '{';
                case ']':
                    return c2 == '[';
                case ')':
                    return c2 == '(';
                default:
                    return false;
            }
        }
        bool isValid(string s) {
            stack<char> st;
            int n = s.size();
            for(int i = 0; i < n; i++) {
                char c1 = s[i];
                if(c1 == '(' || c1 == '{' || c1 == '[') {
                    st.push(c1);
                } else {
                    if(st.empty()) return false;
                    if(!check(c1, st.top())) return false;
                    st.pop();
                }
            }
            return st.empty();
        }
    };
```

分析：利用栈的原理先进后出

## 无重复字符的最长子串

题目：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

相似题目：[至多包含两个不同字符的最长子串](# 至多包含两个不同字符的最长子串)

>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
>
>**示例 1:**
>
>```
>输入: "abcabcbb"
>输出: 3 
>解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
>```
>
>**示例 2:**
>
>```
>输入: "bbbbb"
>输出: 1
>解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
>```
>
>**示例 3:**
>
>```
>输入: "pwwkew"
>输出: 3
>解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
>```

solution:

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int res = 0, left = 0, right = 0, n = s.size();
        unordered_set<char> t;
        while (right < n) {
            if (!t.count(s[right])) {
                t.insert(s[right++]);
                res = max(res, (int)t.size());
            }  else {
                t.erase(s[left++]);
            }
        }
        return res;
    }
};
```

分析：

* 此方法是**滑动窗口**
* 用数据结构来判断 **是否有重复的字符**（即 `C++` 中的 `std::unordered_set`，`Java` 中的 `HashSet`，`Python` 中的 `set`, `JavaScript` 中的 `Set`）
* 使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」

## 至多包含两个不同字符的最长子串

题目：https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters

相似题目：[无重复字符的最长子串](# 无重复字符的最长子串)

>- 给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。
>- 示例 1:
>  输入: “eceba”
>  输出: 3
>  解释: t 是 “ece”，长度为3。
>- 示例 2:
>  输入: “ccaabbb”
>  输出: 5
>  解释: t 是 “aabbb”，长度为5。

solution:

```c++
// 滑动窗口
// 时间复杂度：O(n) 空间复杂度：O(n)
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        unordered_map<char, int> m;
        int cnt = 0;                // 不同字符个数
        int left = 0, right = 0;    // right指向的是窗口外的下一个字符
        int maxLen = 0;
        while(right < s.size()){
            if(m[s[right]] == 0)
                cnt ++;             // 出现新字符
            m[s[right++]]++;        // 计数+1并右移
            while(cnt > 2){         // 当窗口元素大于2，窗口缩小
                m[s[left]]--;       // 计数-1
                if(m[s[left++]] == 0){
                    cnt --;         // 字符计数减为0
                }
            }
            maxLen = max(maxLen, right - left); // 满足条件的窗口长度
        }
        return maxLen;
    }
};
```

分析：

* 利用cnt来维护不同字符个数，使窗口内不同字符个数不超过2
* 如果超过2，此时temp = s[left], 则left指针往后移，一直到最后一个temp被移出去。
* 如果是求至多包含 K 个不同字符的最长子串，则将`cnt > 2`换为`cnt > k`即可，如下：

```c++
/*
 * 滑动窗口+哈希表
 * 时间复杂度O(n) 空间复杂度O(k)
 */
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        if(s.size() == 0 || k <= 0)
            return 0;
        int cnt = 0;                // 不同字符个数
        int left = 0, right = 0;    // right指向的是窗口外的下一个字符
        int maxLen = 0;
        while(right < s.size()){
            if(m[s[right]] == 0)
                cnt ++;             // 出现新字符
            m[s[right++]]++;        // 计数+1并右移
            while(cnt > k){         // 当窗口元素大于2，窗口缩小
                m[s[left]]--;       // 计数-1
                if(m[s[left++]] == 0){
                    cnt --;         // 字符计数减为0
                }
            }
            maxLen = max(maxLen, right - left); // 满足条件的窗口长度
        }
        return maxLen;
    }
};
```

## K 个不同整数的子数组

题目：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/

>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。
>
>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）
>
>返回 A 中好子数组的数目。
>
>
>
>**示例 1：**
>
>```
>输入：A = [1,2,1,2,3], K = 2
>输出：7
>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
>```
>
>**示例 2：**
>
>```
>输入：A = [1,2,1,3,4], K = 3
>输出：3
>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
>```
>
>
>提示：
>
>1 <= A.length <= 20000
>1 <= A[i] <= A.length
>1 <= K <= A.length

```C++
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int left = 0;
        int right = 0;
        int ans = 0;
        int n = A.size();

        // 表内数字表示当前存储的数字以及个数
        unordered_map<int, int> hash;
        while (right < n) {
            hash[A[right++]]++;

            // 表内超过最大数据时，需要缩小窗口
            while (hash.size() > K) {
                if (hash[A[left]] > 1) {
                    hash[A[left]]--;
                } else {
                    hash.erase(A[left]);
                }
                left++;
            }

            // 表内数据刚好是K时，计算所有结果
            int tmp = left;
            while(hash.size() == K) {
                ans++;
                if (hash[A[tmp]] > 1) {
                    hash[A[tmp]]--;
                } else {
                    hash.erase(A[tmp]);
                }
                tmp++;
            }

            // tmp用作计算，hash中数据需要恢复
            while(tmp > left) {
                hash[A[tmp-1]]++;
                tmp--;
            }
        }
        return ans;
    }
};

```

**解题思路**

* 双指针+滑动窗口
* 1、题目中要求不同元素个数为K，我们其实可以固定一个含K个不同元素的窗口并且不断往右扩展窗口，hash表维持，当窗口内元素等于K时进行统计，超过K时，从左开始缩小窗口，其实也是含双指针的意思
* 2、窗口中元素个数满足的状态下进行结果统计，这个结果统计有一定技巧，比如[1 2 2 1]窗口，首先[1 2 2 1]必然会第一个统计，那么[2 2 1]和[2 1]呢，可以通过移动左侧窗口同时保持窗口内含K个元素的特征，进行统计，右边窗口不能移动。3、需要注意的是，在进行左窗口滑动遍历后，需要进行hash数据的恢复，中间只是
* 3、用作临时计算改变了hash表中存储的数据值。
* **复杂度分析**
  - 时间复杂度： O(N)，其中 N*N* 是数组 `A` 的大小。
  - 空间复杂度： O(N)。

# 数组

## 调整数组顺序使奇数位于偶数前面

题目：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/

>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
>
>示例：
>
>```
>输入：nums = [1,2,3,4]
>输出：[1,3,2,4] 
>注：[3,1,2,4] 也是正确的答案之一。
>```

solution：

```C++
class Solution {
public:
    vector<int> exchange(vector<int>& nums) {
        int left = 0;
        int right = nums.size()-1;
        while(left < right) {
            while((nums[left] % 2 == 1) && left < right) {
                left++;
            }
            while((nums[right] % 2 == 0) && left < right) {
                right--;
            }
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        }
        return nums;
    }
};
```

分析：

* 双指针，也可以快慢指针



## 排序矩阵查找

题目：https://leetcode-cn.com/problems/sorted-matrix-search-lcci/

>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。
>
>示例:
>
>```
>现有矩阵 matrix 如下：
>
>[
>  [1,   4,  7, 11, 15],
>  [2,   5,  8, 12, 19],
>  [3,   6,  9, 16, 22],
>  [10, 13, 14, 17, 24],
>  [18, 21, 23, 26, 30]
>]
>给定 target = 5，返回 true。
>
>给定 target = 20，返回 false。
>```

solution:

```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        bool found = false;
        int rows = matrix.size();
        if(rows <=0)
            return found;
        int columns = matrix[0].size();
        int column = columns - 1;
        int row = 0;
        while(row < rows && column >= 0) { //注意column可以等于0
            int temp = matrix[row][column];
            if(temp == target) {
                found = true;
                break;
            } else if(temp > target) {
                column--;
            } else {
                row++;
            }           
        }
        return found;
    } 
};
```

分析：

* 这道题重点是从右上方向下向左遍历
* 时间复杂度为$$O(M*N)$$,空间复杂度为$$O(1)$$
* 注意返回值初始化，考虑输入特殊值处理
* 如果数据量特别大的话可以考虑每一行和每一列采用二分法找位置。

## 删除排序数组中的重复项

题目：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

相似题目：[删除排序链表中的重复元素](# 删除排序链表中的重复元素)

>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。
>
>**示例 1:**
>
>```
>给定数组 nums = [1,1,2], 
>
>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
>你不需要考虑数组中超出新长度后面的元素。
>```
>
>**示例 2:**
>
>```
>给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>```
>
>你不需要考虑数组中超出新长度后面的元素。

solution：

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        int slow = 0, fast = 1;
        while (fast < n) {
            if (nums[fast] != nums[slow]) {
                slow++;
                // 维护 nums[0..slow] 无重复
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 长度为索引 + 1
        return slow + 1; 
    }
};
```

分析：让慢指针 `slow` 走左后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，**`nums[0..slow]` 就是不重复元素，之后的所有元素都是重复元素**。

我们知道对于数组来说，在尾部插入、删除元素是比较高效的，时间复杂度是 O(1)，但是如果在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为 O(N)，效率较低。

显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。而且题目要求我们原地修改，也就是说不能用辅助数组，空间复杂度得是 O(1)。

## 把数组排成最小的数

题目：https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/

>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
>
>示例 1:
>
>输入: [10,2]
>输出: "102"
>示例 2:
>
>输入: [3,30,34,5,9]
>输出: "3033459"

solution:

```C++
class Solution {
public:
    static bool compare(int a,int b){
        string strNum1=to_string(a);
        string strNum2=to_string(b);
        return (strNum1+strNum2)<(strNum2+strNum1);
    }
    string minNumber(vector<int>& nums) {
        string result;
        if(nums.empty())
            return result;
        sort(nums.begin(),nums.end(),compare);
        for(unsigned int i=0;i<nums.size();i++)
            result+=to_string(nums[i]);
        return result;
    }
};
```

分析：

* 可以转换为字符串，利用字符串的比较特性
* 升序排列应该用，**(strNum1+strNum2)<(strNum2+strNum1);**

## 最小的K个数

题目：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/

>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
>
>**示例 1**：
>
>```
>输入：arr = [3,2,1], k = 2
>输出：[1,2] 或者 [2,1]
>```
>
>**示例 2：**
>
>```
>输入：arr = [0,1,2,1], k = 1
>输出：[0]
>```
>
>
>限制：
>
>0 <= k <= arr.length <= 10000
>0 <= arr[i] <= 10000

solution

1. 排序

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> vec(k, 0);
        sort(arr.begin(), arr.end());
        for (int i = 0; i < k; ++i) vec[i] = arr[i];
        return vec;
    }
};
```

分析：

复杂度分析

时间复杂度：O(nlog n)，其中 n是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(nlog n)，排序所需额外的空间复杂度为 O(nlog n)。

2. 堆

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int>vec(k, 0);
        if (k == 0) return vec; // 排除 0 的情况
        priority_queue<int>Q;
        for (int i = 0; i < k; ++i) Q.push(arr[i]);
        for (int i = k; i < (int)arr.size(); ++i) {
            if (Q.top() > arr[i]) {
                Q.pop();
                Q.push(arr[i]);
            }
        }
        for (int i = 0; i < k; ++i) {
            vec[i] = Q.top();
            Q.pop();
        }
        return vec;
    }
};
```

分析：

* 我们用一个大根堆实时维护数组的前 k小值。首先将前 k个数插入大根堆中，随后从第 k+1个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的堆为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 k 小值。
* 时间复杂度：`O(nlog(k))`，其中 n是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 `O(log(k))` 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要`O(nlog(k))` 的时间复杂度。
* 空间复杂度：`O(k)`，因为大根堆里最多 k 个数。

3. 快排思想

```c++
class Solution {
public:
    int partition(vector<int>& data, int low, int high)
    {
        int temp = data[low];
        while(low < high){
            while((low < high) && (data[high] >= temp)){
                high--;
            }
            data[low] = data[high];
            while((low < high) && (data[low] <= temp)){
                low++;
            }
            data[high] = data[low];

        }
        data[low] = temp;
        return low;
    }
    void randomized_selected(vector<int>& arr, int l, int r, int k) {
        if (l >= r) return;
        int pos = partition(arr, l, r);
        int num = pos - l + 1; // l到pos之间小于等于arr[pos]的个数
        if (k == num) return;
        else if (k < num) randomized_selected(arr, l, pos - 1, k);
        else randomized_selected(arr, pos + 1, r, k - num);  
    }
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        randomized_selected(arr, 0, (int)arr.size() - 1, k);
        vector<int>vec;
        for (int i = 0; i < k; ++i) vec.push_back(arr[i]);
        return vec;

    }
};
```

* >
  >
  >我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。
  >
  >我们定义函数 randomized_selected(arr, l, r, k) 表示划分数组 arr 的 [l,r] 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：
  >
  >​	1) 如果 pos - l + 1 == k，表示 pivot 就是第 kk 小的数，直接返回即可；
  >
  >​	2) 如果 pos - l + 1 < k，表示第 k 小的数在 pivot 的右侧，因此递归调用 randomized_selected(arr, pos + 1, r, k - (pos - l + 1))；
  >
  >​	3) 如果 pos - l + 1 > k，表示第 k小的数在 pivot 的左侧，递归调用 randomized_selected(arr, l, pos - 1, k)。
  >
  >函数递归入口为 randomized_selected(arr, 0, arr.length - 1, k)。在函数返回后，将前 k 个数放入答案数组返回即可。
  >

* 时间复杂度：期望为 `O(n)` ，由于证明过程很繁琐，所以不再这里展开讲。具体证明可以参考《算法导论》第 9 章第 2 小节。最坏情况下的时间复杂度为 `O(n^2)`。情况最差时，每次的划分点都是最大值或最小值，一共需要划分 `n - 1`次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 `O(n^2)`。

* 空间复杂度：期望为 `O(log n)`，递归调用的期望深度为 `O(log n)`，每层需要的空间为` O(1)`，只有常数个变量。最坏情况下的空间复杂度为 `O(n)`。最坏情况下需要划分 n 次，即 randomized_selected 函数递归调用最深 n - 1 层，而每层由于需要 `O(1)` 的空间，所以一共需要` O(n)`的空间复杂度。

## 丑数

题目：https://leetcode-cn.com/problems/ugly-number/

>编写一个程序判断给定的数是否为丑数。
>
>丑数就是只包含质因数 2, 3, 5 的正整数。
>
>示例 1:
>
>输入: 6
>输出: true
>解释: 6 = 2 × 3
>示例 2:
>
>输入: 8
>输出: true
>解释: 8 = 2 × 2 × 2
>示例 3:
>
>输入: 14
>输出: false 
>解释: 14 不是丑数，因为它包含了另外一个质因数 7。

solution:

```C++
class Solution {
public:
    bool isUgly(int num) {
        while(num >= 2 ) {
            if(num % 2 == 0) {
                num = num / 2;
            } else if(num % 3 == 0) {
                num = num / 3;
            } else if(num % 5 == 0) {
                num = num / 5;
            } else {
                return false;
            }
        }
        return num == 1;
    }
};
```

## 丑数 II

题目：https://leetcode-cn.com/problems/ugly-number-ii/

>编写一个程序，找出第 n 个丑数。
>
>丑数就是质因数只包含 2, 3, 5 的正整数。
>
>示例:
>
>输入: n = 10
>输出: 12
>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
>说明:  

solution:

```C++
class Solution {
public:
    int Min(int i, int j, int k) {
        int m = i > j ? j : i;
        return m > k ? k : m;
    }
    int nthUglyNumber(int n) {
        int min = 0;
        int uglyNums[n];
        int m2=0, m3=0, m5=0;
        int next = 1;
        uglyNums[0] = 1;
        while(next < n) {
            min = Min(uglyNums[m2]*2, uglyNums[m3]*3, uglyNums[m5]*5);
            uglyNums[next++] = min;
            if(min == uglyNums[m2]*2)
                m2++;
            if(min == uglyNums[m3]*3)
                m3++;
            if(min == uglyNums[m5]*5)
                m5++;
        }
        return uglyNums[n - 1];
    }
};
```

## 丑数 III

题目：

>请你帮忙设计一个程序，用来找出第 n 个丑数。
>
>丑数是可以被 a 或 b 或 c 整除的 正整数。
>
> 
>
>示例 1：
>
>输入：n = 3, a = 2, b = 3, c = 5
>输出：4
>解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。
>示例 2：
>
>输入：n = 4, a = 2, b = 3, c = 4
>输出：6
>解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。
>示例 3：
>
>输入：n = 5, a = 2, b = 11, c = 13
>输出：10
>解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。
>示例 4：
>
>输入：n = 1000000000, a = 2, b = 217983653, c = 336916467
>输出：1999999984

solution：

```C++
class Solution {
public:
    long LCM(long a, long b) {
        return a * (b / __gcd(a, b));
    }
    int nthUglyNumber(int n, int a, int b, int c) {
        long ab = LCM(a, b);
        long ac = LCM(a, c);
        long bc = LCM(b, c);
        long abc = LCM(ab, c);
        long l = min(a, min(b, c));
        long r = 2 * 10e9;
        while (l < r) {
            long m = l + (r - l) / 2;
            long count = m / a + m / b + m / c - m / ab - m / ac - m / bc + m / abc;
            if (count < n) {
                l = m + 1;
            } else {
                r = m;
            }
        }
        return l;
    }
};
```

分析：

* 对于一个数，有多少个丑数小于等于该数是可以快速计算出来的
* 因此可以用二分搜索定位该数
*  `__gcd是最大公约数，最小公倍数为`a * (b / __gcd(a, b))`;`

## 超级丑数

题目：https://leetcode-cn.com/problems/super-ugly-number/

>编写一段程序来查找第 n 个超级丑数。
>
>超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。
>
>示例:
>
>输入: n = 12, primes = [2,7,13,19]
>输出: 32 
>解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
>说明:
>
>1 是任何给定 primes 的超级丑数。
> 给定 primes 中的数字以升序排列。
>0 < k ≤ 100, 0 < n ≤ 106, 0 < primes[i] < 1000 。
>第 n 个超级丑数确保在 32 位有符整数范围内。
>通过次数8,396提交次数13,341

solution:

```C++
class Solution {
public:
        int nthSuperUglyNumber(int n, vector<int>& primes) {
            int min = 0;
            int next = 1;
            int uglyNums[n];
            uglyNums[0] = 1;
            int length = primes.size();
            int index[length];
            for(int i = 0; i < length; i++) {
                index[i] = 0;
            }
            while(next < n) {
                min = INT_MAX;
                for(int i = 0; i< length; i++) {
                    if(uglyNums[index[i]] * primes[i] < min) {
                        min = uglyNums[index[i]] * primes[i];
                    }
                }
                uglyNums[next++] = min;
                for(int i = 0; i< length; i++) {
                    if(uglyNums[index[i]] * primes[i] == min) {
                        index[i]++;
                    }
                }
            }
            return uglyNums[n - 1];
        }
};
```



## 第K个只包含素因子的数

题目：https://leetcode-cn.com/problems/get-kth-magic-number-lcci/

类似题目：https://leetcode-cn.com/problems/chou-shu-lcof/

https://leetcode-cn.com/problems/ugly-number/submissions/

https://leetcode-cn.com/problems/ugly-number-ii/

https://leetcode-cn.com/problems/super-ugly-number/

>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
>
>示例 1:
>
>输入: k = 5
>
>

solution：

```c++
class Solution {
public:
    int Min(int i, int j, int k) {
        int m = i > j ? j : i;
        return m > k ? k : m;
    }
    int getKthMagicNumber(int k) {
        int min = 0;
        int uglyNums[k];
        int m3=0, m5=0, m7=0;
        int next = 1;
        uglyNums[0] = 1;
        while(next < k) {
            min = Min(uglyNums[m3]*3, uglyNums[m5]*5, uglyNums[m7]*7);
            uglyNums[next++] = min;
            if(min == uglyNums[m3]*3)
                m3++;
            if(min == uglyNums[m5]*5)
                m5++;
            if(min == uglyNums[m7]*7)
                m7++;
        }
        return uglyNums[k - 1];         
    }
};
```

分析：

* 这个和找出第n个丑数题目类似，维护三个指针，分别是乘以3，乘以5，乘以7; 每次取这三个指针对应数的下一个中的最小者，如uglyNums[m3]的下一个数uglyNums[m3]*3， 然后给最小者加入uglyNums数组；
* 时间复杂度和空间复杂度都是`O(k)`

## 岛屿的数量

题目：https://leetcode-cn.com/problems/number-of-islands/

>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
>
>##### 示例：
>
>> **示例 1:**
>>  **输入:**
>>  11110
>>  11010
>>  11000
>>  00000
>>  **输出:** 1
>>  **示例 2:**
>>  **输入:**
>>  11000
>>  11000
>>  00100
>>  00011
>>  **输出:** 3

solution:

```c++
    class Solution {
    public:
        void search(vector<vector<char>>& grid, int x, int y) {
            if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != '1') return;
            grid[x][y] = '0';
            search(grid, x - 1, y);
            search(grid, x + 1, y);
            search(grid, x, y - 1);
            search(grid, x, y + 1);
        }
        int numIslands(vector<vector<char>>& grid) {
            int count = 0;
            if(grid.empty()) return count;
            int rows = grid.size();
            int columns = grid[0].size();
            for(int i = 0; i < rows; i++) {
                for(int j = 0; j < columns; j++) {
                    if(grid[i][j] == '1') {
                        search(grid, i, j);
                        count++;
                    }
                }
            }
            return count;
        }
    };
```

分析：

* 将已经遍历的节点值更改为0，查看四个方向的DFS

* 复杂度分析

  时间复杂度：O(MN)，其中 M和 N 分别为行数和列数。

  空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到 M N。


## Number of Islands II

题目：https://www.lintcode.com/problem/number-of-islands-ii/description

>给定 n, m, 分别代表一个二维矩阵的行数和列数, 并给定一个大小为 k 的二元数组A. 初始二维矩阵全0. 二元数组A内的k个元素代表k次操作, 设第i个元素为 `(A[i].x, A[i].y)`, 表示把二维矩阵中下标为A[i].x行A[i].y列的元素由海洋变为岛屿. 问在每次操作之后, 二维矩阵中岛屿的数量. 你需要返回一个大小为k的数组.
>
>### **Example**
>
>**样例 1:**
>
>```
>输入: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]]
>输出: [1,1,2,2]
>解释: 
>0.  00000
>    00000
>    00000
>    00000
>1.  00000
>    01000
>    00000
>    00000
>2.  01000
>    01000
>    00000
>    00000
>3.  01000
>    01000
>    00000
>    00010
>4.  01000
>    01000
>    00000
>    00011
>```
>
>**样例 2:**
>
>```
>输入: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]
>输出: [1,1,2,2]
>```

solution：

```c++
class Solution {
public:
    vector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {
        vector<int> res;
        int cnt = 0;
        vector<int> roots(m * n, -1);
        vector<vector<int>> dirs{{0, -1}, {-1, 0}, {0, 1}, {1, 0}};
        for (auto &pos : positions) {
            int id = n * pos[0] + pos[1];
            if (roots[id] != -1) {
                res.push_back(cnt);
                continue;
            }
            roots[id] = id;
            ++cnt;
            for (auto dir : dirs) {
                int x = pos[0] + dir[0], y = pos[1] + dir[1], cur_id = n * x + y;
                if (x < 0 || x >= m || y < 0 || y >= n || roots[cur_id] == -1) continue;
                int p = findRoot(roots, cur_id), q = findRoot(roots, id);
                if (p != q) {
                    roots[p] = q;
                    --cnt;
                }
            }
            res.push_back(cnt);
        }
        return res;
    }
    int findRoot(vector<int>& roots, int id) {
        int tmp = id;
        while (id != roots[id])
            id = roots[id];
        //路径压缩
        while (tmp != roots[tmp]) {
            roots[tmp] = id;
            tmp = roots[tmp];
        }
        return id;
    }
};
```

分析：

* 为了解决这种陆地之间会合并的情况，最好能够将每个陆地都标记出其属于哪个岛屿
* 并查集
* 当前这两个 land 是相邻的，它们是属于一个岛屿，所以其 getRoot 函数的返回值 suppose 应该是相等的，但是如果返回值不同，说明需要合并岛屿，将两个返回值建立关联，并将岛屿计数 cnt 减1。当遍历完当前点的所有邻居时，该合并的都合并完了，将此时的岛屿计数 cnt 存入结果中
* 通过改变并查集的roots[id]来标记是否被扫描过， roots[cur_id] == -1代表没有被扫描过

## 寻找旋转排序数组中的最小值

题目：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/

>假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
>请找出其中最小的元素。
>
>你可以假设数组中**不存在重复元素**。
>
>示例 1:
>
>```
>输入: [3,4,5,1,2]
>输出: 1
>```
>
>示例 2:
>
>```
>输入: [4,5,6,7,0,1,2]
>输出: 0
>```

solution：

```C++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size()-1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return nums[left];
    }
};
```

分析：

* 二分法遍历，注意和nums[right]比较

## 寻找旋转排序数组中的最小值 II

题目：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/

>假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
>
>请找出其中最小的元素。
>
>注意数组中**可能存在重复的元素**。
>
>示例 1：
>
>输入: [1,3,5]
>输出: 1
>示例 2：
>
>输入: [2,2,2,0,1]
>输出: 0
>说明：
>
>这道题是 寻找旋转排序数组中的最小值 的延伸题目。
>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？
>
>

solution:

```C++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size()-1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < nums[right]) {
                right = mid;
            } else if(nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right--;/考虑201222情况；
            }
        }
        return nums[left];
    }
};
```

分析：

* 这种解法值得思考，只是针对mid 和right来判断指针变化，用left 和right比较来判断是否完成，可以推广到所有的二分比较

## 合并区间

题目：

>给出一个区间的集合，请合并所有重叠的区间。
>
>示例 1:
>
>```
>输入: [[1,3],[2,6],[8,10],[15,18]]
>输出: [[1,6],[8,10],[15,18]]
>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
>```
>
>示例 2:
>
>```
>输入: [[1,4],[4,5]]
>输出: [[1,5]]
>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间
>```

solution:

```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        vector<vector<int>> result;
        sort(intervals.begin(), intervals.end());
        result.push_back(intervals[0]);
        for(int i=1; i<intervals.size(); i++) {
            vector<int> preIn = result.back();
            vector<int> curIn = intervals[i];
            if(preIn[1]>=curIn[0] && preIn[1]<curIn[1]) {
                preIn[1] = curIn[1];
                result.pop_back();
                result.push_back(preIn);
            } else if(preIn[1]<curIn[0]) {
                result.push_back(curIn);
            }
        }
        return result;
    }
};
```

分析：

* 先排序，然后再比较区间
* 时间复杂度：$$O(nlogn)$$，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 $$O(n\log n)$$。
* 空间复杂度：$O(\log n)$，其中 n 为区间的数量。这里计算的是存储答案之外，使用的额外空间。$$O(logn)$$ 即为排序所需要的空间复杂度。

## 插入区间

题目：https://leetcode-cn.com/problems/insert-interval/

>给出一个无重叠的 ，按照区间起始端点排序的区间列表。
>
>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
>
>示例 1:
>
>```
>输入: intervals = [[1,3],[6,9]], newInterval = [2,5]
>输出: [[1,5],[6,9]]
>```
>
>示例 2:
>
>```
>输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
>输出: [[1,2],[3,10],[12,16]]
>解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
>```

solution:

```C++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> res;
        int cur = 0;
        for(int i = 0; i < intervals.size(); i++) {
            if(intervals[i][1] < newInterval[0]) {
                res.push_back(intervals[i]);
                cur++;
            } else if(intervals[i][0] > newInterval[1]) {
                res.push_back(intervals[i]);
            } else {
                newInterval[0] = min(intervals[i][0], newInterval[0]);
                newInterval[1] = max(intervals[i][1], newInterval[1]);
            }
        }
        res.insert(res.begin() + cur, newInterval);
        return res;        
    }
};
```

分析：

* 时间复杂度：$$O(n)$$，其中 n 为区间的数量。

* 空间复杂度：$O(n)$，其中 n 为区间的数量。

* 错误解答：

  ```C++
  class Solution {
  public:
      vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
          vector<vector<int>> res;
          int cur = 0;
          for(int i = 0; i < intervals.size(); i++) {
              if(intervals[i][1] < newInterval[0]) {
                  res.push_back(intervals[i]);
                  cur++;
              } else if(intervals[i][0] > newInterval[1]) {
                  res.push_back(intervals[i]);
              } else {
                  newInterval[0] = min(intervals[i][0], newInterval[0]);
                  newInterval[1] = max(intervals[i][1], newInterval[1]);
                  res.push_back(newInterval);
              }
          }
          return res;        
      }
  };
  ```

  

## 顺时针打印矩阵

题目:https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/

>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
>
> 
>
>示例 1：
>
>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
>输出：[1,2,3,6,9,8,7,4,5]
>示例 2：
>
>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
>输出：[1,2,3,4,8,12,11,10,9,5,6,7]

solution:

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 存储结果
        vector<int> result;
        // 边界条件
        if(matrix.empty())
            return result;
        // 二维矩阵行列
        int rows = matrix.size();
        int cols = matrix[0].size();
        // 圈的四个角标
        int left = 0;
        int right = cols-1;
        int top = 0;
        int btm = rows-1;
        // 循环打印圈
        while(left <= right && top <= btm){             // 循环条件：
            // 圈的第一步
            for(int i=left;i<=right;++i)                // 第一步循环条件
                result.push_back(matrix[top][i]);       // 第一步坐标
            // 圈的第二步
            if(top<btm)                                 // 第二步边界条件
                for(int i=top+1;i<=btm;++i)             // 第二步循环条件
                    result.push_back(matrix[i][right]); // 第二步坐标
            // 圈的第三步
            if(top<btm && left<right)                   // 第三步边界条件
                for(int i=right-1;i>=left;--i)          // 第三步循环条件
                    result.push_back(matrix[btm][i]);   // 第三步坐标
            // 圈的第四步
            if(top+1<btm && left<right)                 // 第四步边界条件
                for(int i=btm-1;i>=top+1;--i)           // 第四步循环条件
                    result.push_back(matrix[i][left]);  // 第四步坐标

            ++left;--right;++top;--btm;
        }
        return result;
    }
};
```

* 注意第四步top+1<btm

# 列表

## 合并两个排序的链表

题目：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/

>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。
>
>示例1：
>
>输入：1->2->4, 1->3->4
>输出：1->1->2->3->4->4
>限制：
>
>0 <= 链表长度 <= 1000
>

soluiton:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
      if(l1 == NULL) {
          return l2;
      }
      else if(l2 == NULL) {
          return l1;
      }
      ListNode* head = NULL;
      if(l1->val > l2->val) {
          head = l2;
          head->next = mergeTwoLists(l1, l2->next);
      }
      else {
          head = l1;
          head->next = mergeTwoLists(l1->next, l2);
      }
      return head;
    }
};
```

## 合并K个排序链表

题目：https://leetcode-cn.com/problems/merge-k-sorted-lists/

>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
>
>示例:
>
>输入:
>[
>  1->4->5,
>  1->3->4,
>  2->6
>]
>输出: 1->1->2->3->4->4->5->6
>
>

solution:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
struct cmp {
    bool operator () (ListNode *a, ListNode *b) {
        return a->val > b->val;
    }
};
    
class Solution {  
public:  
    ListNode *mergeKLists(vector<ListNode *> &lists) {  
        priority_queue<ListNode*, vector<ListNode*>, cmp> q;
        for (int i = 0; i < lists.size(); ++i) {
            if (lists[i]) q.push(lists[i]);
        }
        ListNode *head = NULL, *pre = NULL, *tmp = NULL;
        while (!q.empty()) {
            tmp = q.top();
            q.pop();
            if (!pre) head = tmp;
            else pre->next = tmp;
            pre = tmp;
            if (tmp->next) q.push(tmp->next);
        }
        return head;
    }  
};
```

分析：

* 优先队列
* 时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(logk)，这里最多有kn 个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为O(kn×logk)。
* 空间复杂度：这里用了优先队列，优先队列中的元素不超过 k 个，故渐进空间复杂度为O(k)。

## 反转链表

题目：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
>
>示例:
>
>输入: 1->2->3->4->5->NULL
>输出: 5->4->3->2->1->NULL
>
>

solution：

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
      ListNode* reverseHead = NULL;
      ListNode* pNode = head;
      ListNode* tailNode = NULL;
      while(pNode != NULL)
      {
          ListNode* pNext = pNode->next;
          if(pNext == NULL)
          {
              reverseHead = pNode;
          }
          pNode->next = tailNode;
          tailNode = pNode;
          pNode = pNext;
      }
      return reverseHead;
    }
};
```

## 复杂链表的复制

题目：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/

>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
>
>

solution：

````C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == NULL)
            return head;
        cloneNodes(head);
        connectRandomNodes(head);
        return reConnectNodes(head);
    }
    void cloneNodes(Node* head) {
        Node* pNode = head;
        while(pNode != NULL) {
            Node* copy = new Node(pNode->val);
            copy->next = pNode->next;
            copy->random = NULL; //先赋值pNode->random没有意义
            pNode->next = copy;
            pNode = copy->next;
        }
    }
    void connectRandomNodes(Node* head) {
        Node* pNode = head;
        while(pNode != NULL) {
            Node* copy = pNode->next;
            if(pNode->random != NULL) {
                copy->random = pNode->random->next;
            }
            pNode = copy->next;
        }
    }
    Node* reConnectNodes(Node* head) {
        Node* pNode = head;
        Node* copyHead = NULL;
        Node* copyNode = NULL;
        if(pNode->next != NULL) {
            copyHead = copyNode = pNode->next;
            pNode->next = copyNode->next;
            pNode = pNode->next;
        }
        while(pNode != NULL) {
            copyNode->next = pNode->next;
            copyNode = copyNode->next;
            pNode->next =  copyNode->next;
            pNode = pNode->next;
        }
        return copyHead;
    }
};
````



## 链表中倒数第k个节点

题目：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
>
> 
>
>示例：
>
>给定一个链表: 1->2->3->4->5, 和 k = 2.
>
>返回链表 4->5.
>

solution:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
  		if(head == NULL || k<0){
  			return NULL;
  		}      
  		ListNode* firstNode = head;
  		ListNode* secondNode = head;
  		for(int i=0;i<k;i++) {
  			firstNode = firstNode->next;
  		}
  		while(firstNode != NULL) {
  			firstNode = firstNode->next;
  			secondNode = secondNode->next;
  		}
  		return secondNode;
    }
};
```

分析：

* 双向列表
* **时间复杂度 O(N) ：** N 为链表长度；总体看， firstNode 走了 N 步， secondNode 走了$$O(N−k)$$步。
* **空间复杂度 O(1)：** 双指针 `firstNode` , `secondNode` 使用常数大小的额外空间

## 两个链表的第一个公共节点

题目：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

>输入两个链表，找出它们的第一个公共节点。
>
>如下面的两个链表：
>
>在节点 c1 开始相交。
>
>示例 1：
>
>
>
>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
>输出：Reference of the node with value = 8
>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
>
>
>示例 2：
>
>
>
>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
>输出：Reference of the node with value = 2
>输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
>
>
>示例 3：
>
>
>
>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
>输出：null
>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
>解释：这两个链表不相交，因此返回 null。

solution：

本来自己的解法是这样的，没想到连题意都理解错了，我认为只要值相同就可以，但是**链表的公共节点是存的内存地址相同，而不是val相同**

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* res = NULL;
        int lengthA = lengthB = 0;
        while(headA != NULL) {
        	lengthA++;
        	headA = headA->next;
        }
        while(headB != NULL) {
        	lengthA++;
        	headB = headB->next;
        }
        if(lengthA > lengthB) {
        	for(int i=0;i<lengthA-lengthB;i++) {
        		headA = headA->next;
        	}
        }
        if(lengthA < lengthB) {
        	for(int i=0;i<lengthB-lengthA;i++) {
        		headB = headB->next;
        	}
        }
        while(headA != NULL) {
        	if(headA->val == headB->val) {
        		res = headA;
        		break;
        	} else{
        		headA = headA->next;
        		headB = headB->next;
        	}
        }
        return res;
    }
};
```

正确的做法应该是：

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *node1 = headA;
        ListNode *node2 = headB;
        
        while (node1 != node2) {
            node1 = node1 != NULL ? node1->next : headB;
            node2 = node2 != NULL ? node2->next : headA;
        }
        return node1;
    }
};
```

分析：

* 我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。这样，当它们相遇时，所指向的结点就是第一个公共结点。
* 时间复杂度：O(M+N)空间复杂度：O(1)。

## 是否有环 环形列表

题目：https://leetcode-cn.com/problems/linked-list-cycle/

>给定一个链表，判断链表中是否有环。
>
>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
>
>**示例 1：**
>
>```
>输入：head = [3,2,0,-4], pos = 1
>输出：true
>解释：链表中有一个环，其尾部连接到第二个节点。
>```
>
>**示例 2：**
>
>```
>输入：head = [1,2], pos = 0
>输出：true
>解释：链表中有一个环，其尾部连接到第一个节点。
>```
>
>**示例 3：**
>
>```
>输入：head = [1], pos = -1
>输出：false
>解释：链表中没有环。
>```

solution：

```c++
    class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(head == NULL || head->next == NULL) {
                return false;
            } else {
                ListNode *slow = head;
                ListNode *fast = head;
                while(fast != NULL && fast->next != NULL) {
                    slow = slow->next;
                    fast = fast->next->next;
                    if(slow == fast) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
```

* 注意：fast != NULL && fast->next != NULL

## 求环入口

题目：https://leetcode-cn.com/problems/linked-list-cycle-ii/

>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
>
>说明：不允许修改给定的链表。
>
> 
>
>**示例 1：**
>
>```
>输入：head = [3,2,0,-4], pos = 1
>输出：tail connects to node index 1
>解释：链表中有一个环，其尾部连接到第二个节点。
>```
>
>**示例 2：**
>
>```
>输入：head = [1,2], pos = 0
>输出：tail connects to node index 0
>解释：链表中有一个环，其尾部连接到第一个节点。
>```
>
>**示例 3：**
>
>```
>输入：head = [1], pos = -1
>输出：no cycle
>解释：链表中没有环。
>```

solution：

```c++
 /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                slow=head;
                while(slow!=fast){
                    slow=slow->next;
                    fast=fast->next;
                }
                return fast;
            }
        }
        return NULL;
    }
};
```

## 删除排序链表中的重复元素

题目：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

相似题目：[删除排序数组中的重复项](# 删除排序数组中的重复项)

>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
>
>示例 1:
>
>```
>输入: 1->1->2
>输出: 1->2
>```
>
>示例 2:
>
>```
>输入: 1->1->2->3->3
>输出: 1->2->3
>```

solution：

直接法

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* pNode = head;
        while(pNode != NULL && pNode->next != NULL) {
            if(pNode->val == pNode->next->val){
                pNode->next = pNode->next->next;
            } else {
                pNode = pNode->next;
            }
        }
        return head;
    }
};
```

快慢指针

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) return NULL;
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast != NULL) {
            if (fast->val != slow->val) {
                // nums[slow] = nums[fast];
                slow->next = fast;
                // slow++;
                slow = slow->next;
            }
            // fast++
            fast = fast->next;
        }
        // 断开与后面重复元素的连接
        slow->next = NULL;
        return head;
    }
};
```

分析：

## [移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

题目：

>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
>
>示例1:
>
> 输入：[1, 2, 3, 3, 2, 1]
> 输出：[1, 2, 3]
>示例2:
>
> 输入：[1, 1, 1, 1, 2]
> 输出：[1, 2]
>提示：

solutions:

```C++
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL) 
            return head;
        unordered_set<int> set = {head->val};
        ListNode* node = head;
        while(node->next != NULL) {
            ListNode* cur = node->next;
            if(!set.count(cur->val)){
                set.insert(cur->val);
                node = node->next;
            } else {
                node->next = node->next->next; //非常重要
            }       
        }
        return head;
    }
};
```

* node->next = node->next->next; 如果写成node= node->next就不对了。

## 链表求和

题目：https://leetcode-cn.com/problems/sum-lists-lcci/

>给定两个用链表表示的整数，每个节点包含一个数位。
>
>这些数位是反向存放的，也就是个位排在链表首部。
>
>编写函数对这两个整数求和，并用链表形式返回结果。
>
>**示例：**
>
>```
>输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
>输出：2 -> 1 -> 9，即912
>```
>
>
>
>进阶：假设这些数位是正向存放的，请再做一遍。
>
>**示例：**
>
>```
>输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
>输出：9 -> 1 -> 2，即912
>```

solution:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode();
        ListNode* res=head;
        int remain = 0;
        while(l1 != NULL || l2 != NULL || remain>0) {
            int a = l1 != NULL ? l1->val: 0;
            int b = l2 != NULL ? l2->val: 0;
            int temp = a + b + remain;
            remain = temp/10;
            temp = temp % 10;
            ListNode* lNode = new ListNode(temp);
            res->next = lNode;
            res = res->next;
            l1 = l1 != NULL ?l1->next: NULL;
            l2 = l2 != NULL ?l2->next: NULL;
        }
        return head->next;
    }
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* result = new ListNode(0);
        ListNode* res = result;
        int sum = 0;
        while(l1 != NULL || l2 != NULL || sum != 0) {
            if(l1 != NULL) {
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2 != NULL) {
                sum += l2->val;
                l2 = l2->next;
            }
            result = (result->next = new ListNode(sum % 10)); //牛
            sum = sum / 10;
          }
        return res->next;
    }
};
```

分析：

​	这个题可以学习到以下几点：

* 本题解就是用双指针单次遍历，时间复杂度$$O(N)$$,空间复杂度$$O(1)$$

	* 创建一个要用的结构体指针需要用new ListNode()这种分配地址，否则赋值的时候会因为没有地址报错
	* 正常逻辑首先遍历l1和l2均不为空的用逻辑与，然后遍历l1和l2中某个不为空的，但是可以放到一个while循环解决，用逻辑或，这样可以大大降低代码复杂度。
	* 要习惯用一行书写if else赋值语句, C和C++是l2 = l2 != NULL ? l2->next: NULL;， Python是l2 = l2->next if l2 != NULL else NULL

## 两数相加 II

题目：

>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
>你可以假设除了数字 0 之外，这两个数字都不会以零开头。
>
> 
>
>进阶：
>
>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。
>
> 
>
>示例：
>
>输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
>输出：7 -> 8 -> 0 -> 7

solution:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
        while (l1) {
            s1.push(l1-> val);
            l1 = l1-> next;
        }
        while (l2) {
            s2.push(l2-> val);
            l2 = l2-> next;
        }
        int sum = 0;
        ListNode* res = NULL;
        while (!s1.empty() || !s2.empty() || sum != 0) {
            if(!s1.empty()) {
                sum += s1.top();
                s1.pop();
            }
            if(!s2.empty()) {
                sum += s2.top();
                s2.pop();
            }
            ListNode* node = new ListNode(sum % 10);
            node->next = res;
            res = node;
            sum = sum / 10;
        }
        return res;
    }
};
```

分析：

* 利用栈空间先进后出，思路简单，效率较低， 注意和上一题返回顺序不同，所以中间需要逆序

* 还有一种方法：不用递归不用栈不翻转链表，原地计算。 

  ```C++
  class Solution {
  public:
      ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
          int count = 0, temp;
          ListNode *head, *last;
          for(head = l1; head; head = head->next)
              count++;
          for(head = l2; head; head = head->next)
              count--;
          if(count < 0)                       //计算两链表长度，将l1指向长链，l2指向短链，将l2的值加到l1中
              swap(l1,l2);            
          last = head = new ListNode(0);      //在链首加一个值为0的节点作为初始的last节点，如果最终该节点值仍为0则删除该节点
          head->next = l1;
          for(int i = abs(count); i != 0; i--){  //将两链数位对齐
              if(l1->val != 9)
                  last = l1;
              l1 = l1->next;
          }
          while(l1){
              temp = l1->val + l2->val;
              if(temp > 9){                   //如果发生进位，则更新last到l1之间所有数位的值
                  temp -= 10;                 //进位后当前数位最大值为8，故将last指针指向当前数位
                  last->val += 1;
                  last = last->next;
                  while(last != l1){
                      last->val = 0;
                      last = last->next;
                  }
              }
              else if(temp != 9)             
                  last = l1;
              l1->val = temp;
              l1 = l1->next;
              l2 = l2->next;
          }
          return head->val == 1 ? head : head->next;
      }
  };
  ```

  分析：

  * 维护一个指针last指向最后一个小于9的节点
  * 将数位对齐后，依次将两链表数位相加，用一个last指针指向上一个计算后非9的数位，即如果当前数位相加后发生进位，可将last指向的数位加一，然后last节点到当前节点间的所有值为9的节点全都变为0；如果当前数位相加且处理了进位后不为9，则last指针指向当前数位，否则last指针不变，然后下一个数位。

# 树

##  二叉树

### 二叉搜索树的后序遍历序列

题目：

>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
>
>参考以下这颗二叉搜索树：
>
>     		 5
>    	  / \
>    	 2   6
>     	    / \
>     	   1   3
>    示例 1：
>
>输入: [1,6,3,2,5]
>输出: false
>示例 2：
>
>输入: [1,3,2,6,5]
>输出: true

solution:

```C++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        if(postorder.empty())
            return true;
        return isPostorder(postorder, 0, postorder.size());
    }
    bool isPostorder(vector<int>& postorder, int start, int end) {
        if(start >= end)
            return true;
        int i = start;
        int root = postorder[end-1];
        while(postorder[i]<root) {
            i++;
        }
        for(int j=i; j<end-1; j++) {
            if(postorder[j]<root)
                return false;
        }
        return isPostorder(postorder, start, i) && isPostorder(postorder, i, end-1);        
    }
};
```

分析：

* 利用递归分治法
* 时间复杂度：$$O(N^2)$$, 遍历isPostorder是N， 递归深度是N
* 空间复杂度为:$$O(N)$$, 栈的空间占用

```C++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        // 单调栈使用，单调递增的单调栈
        stack<int> stack;
        int pervElem = INT_MAX;
        // 逆向遍历，就是翻转的先序遍历
        for (int i = postorder.size() - 1; i >= 0; --i){
            // 左子树元素必须要小于递增栈顶的元素，否则就不是二叉搜索树
            if (postorder[i] > pervElem){
                return false;
            }
            while (!stack.empty() && postorder[i] < stack.top()){
                // 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点
                // 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了
                pervElem = stack.top();//栈中最后一个元素才是root
                stack.pop();
            }
            // 这个新元素入栈
            stack.push(postorder[i]);
        }
        return true;
    }
};
```

分析：

* 这种解法利用了单调栈的解法，从后向前遍历来确保逆序，大于当前值的入栈，小于当前值则认为上一个值为root，以后的值都为左子树，然后把栈里所有的元素pop。判断条件是左子树的值要小于root值
* 时间复杂度为O(N), 只有一次入栈和一次出栈的时间消耗，时间复杂度为O(N),栈的开销

### 二叉搜索树与双向链表

题目：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/

>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
>
> 
>
>为了让您更好地理解问题，以下面的二叉搜索树为例：
>
> <img src=tree2doubleList.png style="zoom: 50%;" />
>
>
>
>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>
>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
>
> <img src=tree2doubleList2.png />
>
>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
>
>

solution:

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* pre = NULL, *cur = NULL, *head = NULL;

    Node* treeToDoublyList(Node* root) {
        if(root == NULL)
            return NULL;
            
        // 创建一个 resHead 可以省略头节点相关的边界判断， resHead 指向头节点即可
        Node* resHead = new Node;
        resHead -> right = root;  // resHead right 指向 head( 这里使用 left 也可以)
        pre = resHead;            // 对于 head 节点， head 的前一个节点就是 resHead 了。

        _treeToDoublyList(root);   // 进行中序遍历（因为中序遍历前后都要做一些处理， 所以这里把中序遍历单独有写了一个函数）

        // 更新头节点和尾节点的指针， 没有这部分那么此链表就只是一个普通的双向链表， 此处把双向链表变成了双向循环链表。
        resHead -> right -> left = cur;
        cur -> right = resHead -> right;

        return resHead -> right;
    }

    void _treeToDoublyList(Node* root) {
        if(root == NULL)
            return;
        
        _treeToDoublyList(root -> left);

        cur = root;         // 变更开始时更新 cur
        pre -> right = cur; // 变更左右指针的指向， 符合双向链表的指针指向， 即当节点有一个指针指向前一个节点， 前一个节点也有一个指针指向当前节点
        cur -> left = pre;
        pre = root;         // 变结束后更新 pre ， 以便下一次使用

        _treeToDoublyList(root -> right);
    }
};
```



### [二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

题目：

>给定一个二叉树，返回它的 前序 遍历。
>
> 示例:
>
>输入: [1,null,2,3]  
>   1
>    \
>     2
>    /
>   3 
>
>输出: [1,2,3]
>进阶: 递归算法很简单，你可以通过迭代算法完成吗？

solutions:

```C++
class Solution {
public:
    vector<int> result;
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == NULL)
            return result;
        result.push_back(root->val);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
        return result;
    }
};
```

### [二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

题目：

>给定一个二叉树，返回它的中序 遍历。
>
>示例:
>
>输入: [1,null,2,3]
>   1
>    \
>     2
>    /
>   3
>
>输出: [1,3,2]
>进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
>

solutions:

```C++
class Solution {
public:
    vector<int> result;
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == NULL)
            return result;
        inorderTraversal(root->left);
        result.push_back(root->val);
        inorderTraversal(root->right);
        return result;        
    }
};
```

### 二叉树的后序遍历

题目：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/

>给定一个二叉树，返回它的 后序 遍历。
>
>示例:
>
>输入: [1,null,2,3]  
>   1
>    \
>     2
>    /
>   3 
>
>输出: [3,2,1]
>进阶: 递归算法很简单，你可以通过迭代算法完成吗？
>
>

solution:

* 递归

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> result;
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == NULL)
            return result;
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        result.push_back(root->val);
        return result;
    }
};
```

* 迭代

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> result;
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == NULL)
            return result;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            TreeNode* pNode = st.top();
            st.pop();
            if(pNode->left != NULL)
                st.push(pNode->left);
            if(pNode->right != NULL)
                st.push(pNode->right);
            result.push_back(pNode->val);
        }
        reverse(result.begin(), result.end());//和递归的反序一致
        return  result;
    }
};
```

* 时间复杂度：访问每个节点恰好一次，因此时间复杂度为 $$O(N)$$，其中 N 是节点的个数，也就是树的大小。
* 空间复杂度：取决于树的结构，最坏情况需要保存整棵树，因此空间复杂度为 $$O(N)$$。

### 二叉树的层序遍历

题目：

>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
>
> 
>
>示例：
>二叉树：[3,9,20,null,null,15,7],
>
>    		3
>    	 / \
>      9  20
>        /  \
>       15   7
>    
>返回其层次遍历结果：
>
>```
>[
>  [3],
>  [9,20],
>  [15,7]
>]
>```

solution:

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root == NULL) return result;
        queue<TreeNode*> nodes;
        nodes.push(root);
        while(!nodes.empty()) {
            int size = nodes.size();
            vector<int> res;
            for(int i = 0; i< size; i++) {
                TreeNode* node= nodes.front();
                res.push_back(node->val);
                nodes.pop();
                if(node->left) {
                    nodes.push(node->left);
                }
                if(node->right) {
                    nodes.push(node->right);
                }
            }
            result.push_back(res);
        }
        return result;
    }
};
```

分析：

### 二叉树的锯齿形层次遍历

题目：

>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
>
>例如：
>给定二叉树 [3,9,20,null,null,15,7],
>
>    		3
>    	 / \
>      9  20
>        /  \
>       15   7
>    
>
>返回锯齿形层次遍历如下：
>
>```
>[
>  [3],
>  [20,9],
>  [15,7]
>]
>```

solution:

```C++
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root == NULL) return result;
        queue<TreeNode*> nodes;
        nodes.push(root);
        bool level = true;
        while(!nodes.empty()) {
            int size = nodes.size();
            vector<int> res;
            for(int i = 0; i< size; i++) {
                TreeNode* node= nodes.front();
                res.push_back(node->val);
                nodes.pop();
                if(node->left) {
                    nodes.push(node->left);
                }
                if(node->right) {
                    nodes.push(node->right);
                }
            }
            if(!level) {
                reverse(res.begin(), res.end());
            }
            level = !level;
            result.push_back(res);
        }
        return result;
    }
};
```



### 二叉树的竖直遍历

题目：https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/

>
>
>给定一个二叉树，返回其结点 *垂直方向*（从上到下，逐列）遍历的值。
>
>如果两个结点在同一行和列，那么顺序则为 从左到右。
>
>示例 1：
>
>```
>输入: [3,9,20,null,null,15,7]
>
>   3
>  /\
> /  \
>9   20
>    /\
>   /  \
>  15   7 
>
>输出:
>
>[
>  [9],
>  [3,15],
>  [20],
>  [7]
>]
>```
>
>示例 2:
>
>```
>输入: [3,9,8,4,0,1,7]
>
>     3
>    /\
>   /  \
>  9    8
>  /\   /\
> /  \ /  \
>4   0 1   7 
>
>输出:
>
>[
>  [4],
>  [9],
>  [3,0,1],
>  [8],
>  [7]
>]
>```
>
>示例 3:
>
>```
>输入: [3,9,8,4,0,1,7,null,null,null,2,5]（注意：0 的右侧子节点为 2，1 的左侧子节点为 5）
>
>     3
>    /\
>   /  \
>   9   8
>  /\  /\
> /  \/  \
> 4  01   7
>    /\
>   /  \
>   5   2
>
>输出:
>
>[
>  [4],
>  [9,5],
>  [3,0,1],
>  [8,2],
>  [7]
>]
>```
>
>

solution：

```C++
class Solution {
public:
    vector<vector<int>> verticalOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        map<int, vector<int>> m;
        queue<pair<int, TreeNode*>> q;
        q.push({0, root});
        while (!q.empty()) {
            auto a = q.front(); 
            q.pop();
            m[a.first].push_back(a.second->val);
            if (a.second->left) 
                q.push({a.first - 1, a.second->left});
            if (a.second->right) 
                q.push({a.first + 1, a.second->right});
        }
        for (auto a : m) {
            res.push_back(a.second);
        }
        return res;
    }
};
```

### [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

题目：

>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
>示例:
>
>输入: [1,2,3,null,5,null,4]
>输出: [1, 3, 4]
>解释:
>
>   1            <---
> /   \
>2     3         <---
> \     \
>  5     4       <---
>
>

solutions:

```C++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if(!root) return {};
        // bfs 层序遍历 将每层最后一个加入结果数组
        vector<int> ans;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int counts=que.size();
            for(int i=0;i<counts;++i) {
                auto node=que.front();
                que.pop();
                if(node->left)  que.push(node->left);
                if(node->right) que.push(node->right);
                if(i==counts-1) ans.push_back(node->val);
            }
        }
        return ans;
    }
};
```

分析：

* 这个问题可以理解为遍历每一层的最后一个节点
* 如果是左视图就是遍历每一层的第一个节点
* 时间复杂度和空间复杂度都是$$O(N)$$

### 二叉树的镜像

题目：

>请完成一个函数，输入一个二叉树，该函数输出它的镜像。
>
>例如输入：
>
>              4
>            /   \
>           2     7
>          / \   / \
>        1   3 6   9
>        镜像输出：
>             4
>           /   \
>          7     2
>         / \   / \
>        9   6 3   1
> 
>示例 1：
>
>```
>输入：root = [4,2,7,1,3,6,9]
>输出：[4,7,2,9,6,3,1]
>```
>
>
>限制：
>
>0 <= 节点个数 <= 1000
>
>

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
            if(root == NULL) {
                return root;
            }
            TreeNode* temp = root->left;
            root->left = mirrorTree(root->right);
            root->right = mirrorTree(temp);
            return root;
    }
};
```

分析：

* 时间复杂度 O(N) ： 其中 N为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。
* 空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N)空间。

### 验证二叉搜索树

题目：https://leetcode-cn.com/problems/validate-binary-search-tree/

>给定一个二叉树，判断其是否是一个有效的二叉搜索树。
>
>假设一个二叉搜索树具有如下特征：
>
>节点的左子树只包含小于当前节点的数。
>节点的右子树只包含大于当前节点的数。
>所有左子树和右子树自身必须也是二叉搜索树。
>示例 1:
>
>输入:
>    2
>   / \
>  1   3
>输出: true
>示例 2:
>
>输入:
>    5
>   / \
>  1   4
>     / \
>    3   6
>输出: false
>解释: 输入为: [5,1,4,null,null,3,6]。
>     根节点的值为 5 ，但是其右子节点值为 4 。
>
>

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool helper(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;
        if (root -> val <= lower || root -> val >= upper) return false;
        return helper(root -> left, lower, root -> val) && helper(root -> right, root -> val, upper);
    }
    bool isValidBST(TreeNode* root) {
        return helper(root, LONG_MIN, LONG_MAX);
    }
};
```

分析：

* 不能光判断其左子树或者右子树符合左节点值小于root值，右节点值大于root值，还需要判断左节点所有的值小于root值，右节点所有的值大于root值, 以下是错误示例：

  ```
  class Solution {
  public:
      bool isValidBST(TreeNode* root) {
          if(root == NULL) {
              return true;
          }
          bool left = true, right = true;
          if(root->left != NULL) {
              left = (root->left->val < root->val) && isValidBST(root->left);
          }
          if(root->right != NULL) {
              right = (root->val < root->right->val) && isValidBST(root->right);
          }
          return left && right;
      }
  };
  ```

  

### 平衡二叉树

题目：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/

>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
>
> 
>
>**示例 1:**
>
>给定二叉树 [3,9,20,null,null,15,7]
>
>    		 3
>     		/ \
>     	 9  20
>     	   /  \
>     	  15   7
>
>返回 true 。
>
>
>
>示例 2:**
>
>给定二叉树 [1,2,2,3,3,null,null,4,4]
>
>     ​     1
>     ​     / \
>     ​    2   2
>     ​       / \
>     ​      3   3
>     ​     / \
>     ​    4   4
>     
>返回 false 。
>
>
>
> 限制：
>
>1 <= 树的结点个数 <= 10000

solution：

```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
class Solution {
public:
    bool isBalanceWithDepth(TreeNode* node, int& depth) {
      if(node == NULL){
        depth = 0;
        return true;
      }
      int left_depth, right_depth, diff_depth;
      bool left_is_balance = isBalanceWithDepth(node->left, left_depth);
      if(!left_is_balance) //为了剪枝
        return false;
      bool right_is_balance = isBalanceWithDepth(node->right, right_depth);
      if( left_is_balance && right_is_balance) {
        diff_depth = left_depth - right_depth;
        if(diff_depth >= -1 && diff_depth <= 1) {
          depth = left_depth > right_depth?left_depth+1:right_depth+1;
          return true;
        }
      }
      return false;
    }
    bool isBalanced(TreeNode* root) {
      int depth = 0;
      return isBalanceWithDepth(root, depth);
    }
};
```

**note:**优化->剪枝

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/树时间复杂度.png" alt="时间复杂度" style="zoom:50%;" />

​          * **空间复杂度 O(N)：**最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。

### 公共祖先，最低共同父节点

题目：https://leetcode-cn.com/problems/first-common-ancestor-lcci/

相似题目：[最长公共子序列](# 最长公共子序列)

>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。
>
>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
>
>

    	  3  
    	 / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
    示例 1:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输入: 3
    解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
    示例 2:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出: 5
    解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
    说明:
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。

solution：

```c++
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
    * };
    class Solution {
    public:
        bool GetNodePath(TreeNode* pRoot, TreeNode* pNode, list<TreeNode*> & path) {  
            if(pRoot == pNode) {     
                path.push_back(pRoot);  
                return true;  
            }  
            if(pRoot == NULL)
                return false;
            path.push_back(pRoot);  
            bool found = false;  
            found = GetNodePath(pRoot->left, pNode, path);  
            if(!found)  
                found = GetNodePath(pRoot->right, pNode, path);  
            if(!found)  
                path.pop_back();  
            return found;  
        }  

        TreeNode* GetLastCommonNode(const list<TreeNode*>& path1, const list<TreeNode*>& path2) 
        {
            TreeNode* pLast = NULL;  
            list<TreeNode*>::const_iterator iter1 = path1.begin();  
            list<TreeNode*>::const_iterator iter2 = path2.begin();  
            while(iter1 != path1.end() && iter2 != path2.end())  
            {  
                if(*iter1 == *iter2)  
                    pLast = *iter1;  
                else  
                    break;  
                iter1++;  
                iter2++;  
            }  
            return pLast; 
        }

        TreeNode* GetLastCommonParent(TreeNode* pRoot, TreeNode* pNode1, TreeNode* pNode2) {  
            if(pRoot == NULL || pNode1 == NULL || pNode2 == NULL)  
                return NULL;  
            list<TreeNode*> path1;  
            bool bResult1 = GetNodePath(pRoot, pNode1, path1);  
            list<TreeNode*> path2;  
            bool bResult2 = GetNodePath(pRoot, pNode2, path2);  
            if(!bResult1 || !bResult2)   
                return NULL;
            return GetLastCommonNode(path1, path2);   
        }
    };
```

**简单解法：**

```c++
    class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            if (root == p || root == q || root == NULL) return root;
            TreeNode* left = lowestCommonAncestor(root -> left, p, q);
            TreeNode* right = lowestCommonAncestor(root -> right, p, q);
            if (left && right) return root;
            return left ? left : right;
        }
    };
```

**思路：**

本题为了简化题目，已经说明了所有的结点都是唯一的，p、q 不同且均存在于给定的二叉树中。因此我们有以下三种情况：

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/公共节点.png" alt="三种情况" style="zoom:50%;" />

> 难点在于如何书写递归函数，不妨这样思考：
> 假设我们从跟结点开始，采用 DFS 向下遍历，如果当前结点到达叶子结点下的空结点时，返回空；如果当前结点为 p 或 q 时，返回当前结点；
> 这样，当我们令 left = self.lowestCommonAncestor(root.left, p, q) 时，如果在左子树中找到了 p 或 q，left 会等于 p 或 q，同理，right 也是一样；
> 然后我们进行判断：如果 left 为 right 都不为空，则为情况 1；如果 left 和 right 中只有一个不为空，说明这两个结点在子树中，则根节点到达子树再进行寻找。

**复杂度分析**

- 时间复杂度：O(n)。我们需要遍历每一个节点。
- 空间复杂度：O(n)，斜二叉树的高度为 n**。

### 路径总和

题目：https://leetcode-cn.com/problems/path-sum/

>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
>
>说明: 叶子节点是指没有子节点的节点。
>
>示例: 
>给定如下二叉树，以及目标和 sum = 22，
>
>               5
>              / \
>             4   8
>            /   / \
>           11  13  4
>          /  \      \
>         7    2      1
>    返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

solution:

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        return dfs(root, sum);
    }
    bool dfs(TreeNode* root, int sum) {
      if(root == NULL)
        return false;
      sum -= root->val;
      if(root->left == NULL && root->right == NULL && sum == 0){
        return true;
      }
      bool left = dfs(root->left, sum);
      bool right = dfs(root->right, sum);
      return left || right;
    }
};
```

分析：

* DFS， 时间复杂度 $$O(N)$$, 空间复杂度$$O(1)$$



### 二叉树中和为某一值的路径

题目：https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/



>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 
>
>示例:
>给定如下二叉树，以及目标和 sum = 22，
>
>               5
>              / \
>             4   8
>            /   / \
>           11  13  4
>          /  \      \
>         7    2      5
>    返回:
>    [
>    [5,4,11,2],
>       [5,8,4,5]
>       ]
>
>提示：
>
>节点总数 <= 10000
>

solution:

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
      if(root != NULL) {
        dfs(root, sum);
      }
      return res;
    }
    void dfs(TreeNode* root, int sum) {
      if(root == NULL)
        return;
      path.push_back(root->val);
      sum -= root->val;
      if(root->left == NULL && root->right == NULL && sum == 0){
        res.push_back(path);
      }
      dfs(root->left, sum);
      dfs(root->right, sum);
      path.pop_back();
    }
};
```

分析：

* DFS + 回溯法
* 时间复杂度 $$O(N) $$： N 为二叉树的节点数，先序遍历需要遍历所有节点。
  空间复杂度 $$O(N)$$ ： 最差情况下，即树退化为链表时，path 存储所有树节点，使用 $$O(N)$$ 额外空间。

## 前缀树（字典树）

### 实现前缀树

题目：https://leetcode-cn.com/problems/implement-trie-prefix-tree/

>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
>
>**示例:**
>
>```
>Trie trie = new Trie();
>
>trie.insert("apple");
>trie.search("apple");   // 返回 true
>trie.search("app");     // 返回 false
>trie.startsWith("app"); // 返回 true
>trie.insert("app");   
>trie.search("app");     // 返回 true
>```
>
>说明:
>
>你可以假设所有的输入都是由小写字母 a-z 构成的。
>保证所有输入均为非空字符串。

solution:

```C++
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }
    
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c-'a'] == NULL) {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            node = node->next[c - 'a'];
            if (node == NULL) {
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            node = node->next[c-'a'];
            if (node == NULL) {
                return false;
            }
        }
        return true;
    }
};
```

分析：

```c++
Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。

为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：

struct TreeNode {
    VALUETYPE value;    //结点值
    TreeNode* children[NUM];    //指向孩子结点
};
而 Trie 的结点是这样的(假设只包含'a'~'z'中的字符)：

struct TrieNode {
    bool isEnd; //该结点是否是一个串的结束
    TrieNode* next[26]; //字母映射表
};
要想学会 Trie 就得先明白它的结点设计。我们可以看到TrieNode结点中并没有直接保存字符值的数据成员，那它是怎么保存字符的呢？

这时字母映射表next 的妙用就体现了，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：

for (int i = 0; i < 26; i++) {
    char ch = 'a' + i;
    if (parentNode->next[i] == NULL) {
        说明父结点的后一个字母不可为 ch
    } else {
        说明父结点的后一个字母可以是 ch
    }
}

Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。

查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。

Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)
```

### 词典中最长的单词

题目：https://leetcode-cn.com/problems/longest-word-in-dictionary/

>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。
>
>若无答案，则返回空字符串。
>
>示例 1:
>
>输入: 
>words = ["w","wo","wor","worl", "world"]
>输出: "world"
>解释: 
>单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
>示例 2:
>
>输入: 
>words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
>输出: "apple"
>解释: 
>"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。
>注意:
>
>所有输入的字符串都只包含小写字母。
>words数组长度范围为[1,1000]。
>words[i]的长度范围为[1,30]。

**注意**：如果这个有ab,abc，那么是不可以的，因为没有a，也就是说必须最长字母的每一个非空子串都在words里面。

solution:

**排序+hashset法**

```C++
class Solution {
public:
    string longestWord(vector<string>& words) {
        unordered_set<string> hashset;
        string max_word = "";
        if(words.size()==0) return max_word;
        sort(words.begin(), words.end());
        hashset.insert("");
        for(int i=0;i<words.size();i++){
            string word = words[i];
            word.erase(word.size()-1);
            if(hashset.count(word)>0){
                hashset.insert(words[i]);
                if(words[i].size()>max_word.size()) max_word = words[i];//!
                else if(words[i].size()==max_word.size())
                    max_word = max_word<words[i] ? max_word : words[i];//!
            }
        }
        return max_word;
    }
};
```

分析：

1. 先对words进行排序
2. 可以用一个hashset保存字符串（首先加入一个空串，便于长度为1的字符串和大于1的字符串同等处理），如果能找到这个字符串的子串（除去末尾最后一个字符），则将该字符串加入set;
3. 同时保存最长字符串，如果字符串长度相等，则返回字典序小的那个

**字典树法**

```C++
class Trie{
private:
    bool is_string;
    Trie *next[26];
public:
    Trie(){
        is_string=false;
        memset(next,0,sizeof(next));
    }
    
    void insert(string word){
        Trie *root=this;
        for(const auto& w:word){
            if(root->next[w-'a']==nullptr)
                root->next[w-'a']=new Trie();
            root=root->next[w-'a'];
        }
        root->is_string=true;
    }
    
    bool search(string word){
        Trie *root=this;
        for(const auto& w:word){
            //当节点值存在时，判断该节点是否表示为一个字符串，不是的话，直接返回false,否则继续循环;当节点值不存在时直接返回false
            if(root->next[w-'a']==nullptr||root->next[w-'a']->is_string==false)
                return false;
            root=root->next[w-'a'];
        }
        return true;
    }
};
class Solution {
public:
    string longestWord(vector<string>& words) {
        if(words.size()==0)return "";
        Trie* root=new Trie();
        //第一次遍历，建立前缀树
        for(const auto& word:words)
            root->insert(word);
        string result="";
        //第二次遍历，寻找最长单词
        for(const auto& word:words){
            if(root->search(word)){
                if(word.size()>result.size())result=word;//更新最长单词
                else if(word.size()==result.size()&&word<result)result=word;//长度相等的单词，取字典序小的单词
            }    
        }
        return result;
    }
};
```

### 最长单词

题目：https://leetcode-cn.com/problems/longest-word-lcci/

>给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。
>
>示例：
>
>输入： ["cat","banana","dog","nana","walk","walker","dogwalker"]
>输出： "dogwalker"
>解释： "dogwalker"可由"dog"和"walker"组成。

solution：

```C++
class Solution {
public:
    struct TRIE{
        bool end;
        TRIE *next[26];
        TRIE(bool val){
            end=val;
            memset(next,0,sizeof(next));
        }
    };
    
    TRIE *wordtree = new TRIE(false);

    void insert(string word){
        TRIE *curr = wordtree;
        if(word.size()<=0)return;
        for(int i=0; i<word.size();i++){
            int j = word[i]-'a';
            if(curr->next[j]==NULL){
                curr->next[j] = new TRIE(false);
            }
            curr = curr->next[j];
        }
        curr->end = true;

    }

    bool search(string word, int index, int count){
        TRIE *curr = wordtree;
        for(int i=index; i<word.size();i++){
            int j = word[i]-'a';
            if(curr->next[j]==NULL)return false;
            if((curr->next[j])->end){
                if(search(word,i+1,count+1))return true;
            }
            curr = curr->next[j];
        }
        if(index == word.size())return count>1;
        return false;
    }

    string longestWord(vector<string>& words) {
        for(string word:words)insert(word);
        string res;
        for(string word:words){
            if(word.size()<res.size())continue;
            if(word.size()==res.size() && res<=word)continue;
            if(search(word,0,0)){
                res = word;
            }
        }
        return res;
    }
};
```



# 回文

## Palindrome Number 回文数

题目：https://leetcode-cn.com/problems/palindrome-number/

>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
>
>**示例 1:**
>
>```
>输入: 121
>输出: true
>```
>
>**示例 2:**
>
>```
>输入: -121
>输出: false
>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
>```
>
>**示例 3:**
>
>```
>输入: 10
>输出: false
>解释: 从右向左读, 为 01 。因此它不是一个回文数。
>```

solution：

```c++
    public class Solution {
        bool isPalindrome(int x) {
            if(x<0) return false;
            int len=0;
            int temp=x;
            int large=1;
            while(temp>=10){
                large = large*10;
                temp = temp/10;
            }
            while(x>0){
                if(x/large != x%10) return false;
                else{
                    x = x % large;
                    x = x / 10;
                    large = large /100;
                }
            }
            return true;
        }
    }
```

## 判断是否可以形成回文字符串

```c++
    class solution{
    public:
        bool isPalindrome(string str) {
            int count = 0;
            unordered_map<char, int> map;
            for(auto s : str) {
                map[s]++;
            }
            for(auto i = map.begin(); i != map.end(); i++) {
                if(i->second % 2) {
                    count++;
                }
            }
            return count == 0 || (str.size() % 2 == 1 && count == 1);
        }
    }
```

## Palindrome Linked List

题目：https://leetcode-cn.com/problems/palindrome-linked-list/

> 请判断一个链表是否为回文链表。
>
> **示例 1:**
>
> ```
> 输入: 1->2
> 输出: false
> ```
>
> **示例 2:**
>
> ```
> 输入: 1->2->2->1
> 输出: true
> ```

​		solution:

```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode(int x) : val(x), next(NULL) {}
     * };
     */
    class Solution {
    public:
        ListNode* reverse(ListNode* node) {
            ListNode* temp = NULL;
            ListNode* pre = NULL;
            while(node) {
                temp = node->next;
                node->next = pre;
                pre = node;
                node = temp;
            }
            return pre;
        }
        bool isPalindrome(ListNode* head) {
            if(head == NULL || head->next == NULL)
                return true;
            ListNode* fast = head;
            ListNode* slow = head;
            while(fast && fast->next) {
                fast = fast->next->next;
                slow = slow->next;
            }
            //考虑到奇数个节点
            if(fast) {
                slow = slow->next;
            }
            slow = reverse(slow);
            
            while(slow) {
                if(head->val == slow->val) {
                    head = head->next;
                    slow = slow->next;
                } else {
                    return false;
                }
            }
            return true;
        }
    };
```

## 最长回文字符串长度

题目：https://leetcode-cn.com/problems/longest-palindromic-substring/

>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
>
>**示例 1：**
>
>```
>输入: "babad"
>输出: "bab"
>注意: "aba" 也是一个有效答案。
>```
>
>**示例 2：**
>
>```
>输入: "cbbd"
>输出: "bb"
>```

solution：

```c++
    class Solution
    {
    public:
        string longestPalindrome(string s)
        {
            //判断空字符串的情况
            if (s == "") {
                return "";
            }
            string result("");
            int sSize = int(s.size());
            //选择一个中心点，向两侧扩展
            for (int i = 0; i < sSize; i++)
            {
                //奇数组情况
                string tmpStr = expandHelper(s, i, i);
                //偶数组情况
                string tmpStr2 = expandHelper(s, i, i + 1);
                if (int(tmpStr.size()) > int(result.size())) {
                    result = tmpStr;
                }
                if (int(tmpStr2.size()) > int(result.size())) {
                    result = tmpStr2;
                }
            }

            return result;
        }

        string expandHelper(string &s, int left, int right)
        {
            int sSize = int(s.size());
            while (left >= 0 && right < sSize && s[left] == s[right])
            {
                left--;
                right++;
            }
            //s[left] != s[right]
            return (s.substr(left + 1, right - left - 1));
        }
    };
```

**note**: 奇数个字符只能有一个是奇数

# 全排列

## 字符串的排列 回溯法

题目：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

>输入一个字符串，打印出该字符串中字符的所有排列。
>
>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
>
>示例:
>
> ```
>输入：s = "abc"
>输出：["abc","acb","bac","bca","cab","cba"]
>```
>
>

solution：

```c++
class Solution {
public:
    vector<string>res;
    vector<string> permutation(string s) {
        int cursor=0;
        permutation(s,cursor);
        return res;
    }
    void permutation(string &s,int cursor){
        if(cursor==s.size()-1){
            res.push_back(s);
        }
        else{
            for(int i=cursor;i<s.size();i++){
                if(judge(s,cursor,i))continue;  //从cursor开始，遍历不重复的字符
                swap(s[cursor],s[i]);
                permutation(s,cursor+1);
                swap(s[cursor],s[i]);
            }
        }
    }
    bool judge(string& s, int start, int end) {
        for (int i = start; i < end; ++i) {
            if (s[i] == s[end]) return true;
        }
        return false;
    }
};
```

分析：

* 去重方法：只要cursor到i有一个值和end相等既可以跳过

* 如果想不到或者想不清楚去重的方法可以用set如下：

  ```C++
  class Solution {
  public:
      set<string> res;
      void swap(string &s, int i, int j) {
          char temp = s[i];
          s[i] = s[j];
          s[j] = temp;
      }
      vector<string> permutation(string s) {
          if(s.size()==0)
              return vector<string>{};
          permute(s, 0);
          return vector<string>(res.begin(), res.end()) ;
      }
      void permute(string &s, int cursor) {
          if(cursor == s.size()-1) {
              res.insert(s);
          }
          for(int i=cursor; i<s.size();i++) {
              if(i<s.size()-1 && s[i] == s[i+1]){
                  continue;
              }
              swap(s, cursor, i);
              permute(s, cursor+1);
              swap(s, cursor, i);
          }
      }
  };
  ```

  

**note**: 第二个swap是为了还原字符串顺序， pbegin+1

## 无重复元素数组全排列

题目：https://leetcode-cn.com/problems/permutations/

>给定一个 没有重复 数字的序列，返回其所有可能的全排列。
>
>**示例:**
>
>```
>输入: [1,2,3]
>输出:
>[
>  [1,2,3],
>  [1,3,2],
>  [2,1,3],
>  [2,3,1],
>  [3,1,2],
>  [3,2,1]
>]
>```



solution：

```c++
    class Solution {
    public:
        vector<vector<int>> permute(vector<int>& nums) {
            vector<vector<int>> res;
            if(nums.size() == 0) {
                return res;
            } else {
                permutation(nums, 0, res);
            }
            return res;
        }
        
        void permutation(vector<int>& nums, int begin, vector<vector<int>>& res) {
            if(nums.size() <= begin) {
                res.push_back(nums);
                return;
            }
            for(int i = begin; i < nums.size(); i++) {
                swap(nums, begin, i);
                permutation(nums, begin + 1, res);
                swap(nums, begin, i);
            }
        }
        void swap(vector<int>& nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    };
```

## 有重复元素数据全排列

题目：https://leetcode-cn.com/problems/permutations-ii/

>给定一个可包含重复数字的序列，返回所有不重复的全排列。
>
>**示例:**
>
>```
>输入: [1,1,2]
>输出:
>[
>  [1,1,2],
>  [1,2,1],
>  [2,1,1]
>]
>```

solution：

```c++
    class Solution {
    public:
        vector<vector<int>> permuteUnique(vector<int>& nums) {
            set<vector<int>> res;
            permutation(nums, 0, res);
            return vector<vector<int>> (res.begin(), res.end());
        }
        
        void permutation(vector<int>& nums, int begin, set<vector<int>>& res) {
            if(nums.size() <= begin) {
                res.insert(nums);
                return;
            }
            unordered_map<int,bool> used;
            for(int i = begin; i < nums.size(); i++) {
                if(i != begin && nums[i] == nums[begin] && used[nums[i]]) { //此部分剪枝
                    continue;
                }
                used[nums[i]] = true;
                swap(nums, begin, i);
                permutation(nums, begin + 1, res);
                swap(nums, begin, i);
            }
        }
        void swap(vector<int>& nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    };       
```

不用set的方法：

```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        if(nums.size() == 0) {
            return res;
        } else {
            permutation(nums, 0);
        }
        return res;
    }
    void permutation(vector<int>& s,int cursor){
        if(cursor==s.size()-1){
            res.push_back(s);
        }
        else{
            for(int i=cursor;i<s.size();i++){
                if(judge(s,cursor,i))continue;  //从cursor开始，遍历不重复的字符
                swap(s[cursor],s[i]);
                permutation(s,cursor+1);
                swap(s[cursor],s[i]);
            }
        }
    }
    bool judge(vector<int>& s, int start, int end) {
        for (int i = start; i < end; ++i) {
            if (s[i] == s[end]) return true;
        }
        return false;
    }
};
```



## 数字内组合得到下一个比该数大的数Next Permutation

题目：https://leetcode-cn.com/problems/next-permutation/

>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
>必须原地修改，只允许使用额外常数空间。
>
>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
>1,2,3 → 1,3,2
>3,2,1 → 1,2,3
>1,1,5 → 1,5,1

solution:

```c++
    class Solution {
    public:
        void nextPermutation(vector<int>& nums) {
            int j,len=nums.size(),i=len-1,tmp;
            //找出第一个逆序位置
            while(i>0 &&  nums[i]<=nums[i-1])i--;
            if(i>0){
                j=len-1;
                //找出第一个比逆序位置大的数的位置
                while(j>=i && nums[j]<=nums[i-1])j--;
                tmp=nums[i-1];
                nums[i-1]=nums[j];
                nums[j]=tmp;
            }
            j=len-1;
            //对调i-1之后的元素
            while(i<j){
                tmp=nums[i];
                nums[i]=nums[j];
                nums[j]=tmp;
                i++;j--;
            }
        }
    };
```

# 回文全排列

## 给出无重复所有回文全排列

题目：

>Given a string `s`, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.
>
>Example 1:
>
>```
>Input: "aabb"
>Output: ["abba", "baab"]
>```
>
>Example 2:
>
>```
>Input: "abc"
>Output: []
>```
>
>Hint:
>
>1. If a palindromic permutation exists, we just need to generate the first half of the string.
>2. To generate all distinct permutations of a (half of) string, use a similar approach from: [Permutations II](https://leetcode.com/problems/permutations-ii) or [Next Permutation](https://leetcode.com/problems/next-permutation).

solution：

```c++
    class Solution{
    public:
        vector<string> findAllPalindrome(string str) {
            unordered_map<char, int> map;
            unodered_set<string> res;
            string t = "", mid = "";
            for(auto s : str) {
                map[s]++;
            }
            for(auto i = map.begin(); i != map.end(); i++) {
                if(i->second % 2 == 1) {
                    mid += i->first;
                }
                t += string(i->second / 2, i->first);
            }
            if(mid.size() > 1) return {};
            permute(t, 0, mid, res);
            return vector<string>(res.begin(), res.end()); 
        }
        void permute(string &t, int start, string mid, unodered_set<string> &res) {
            if(start >= t.size()) {
                res.insert(t + mid + string(t.rbegin(), t.rend()));
            }
            for(int i = start; i < t.size(); i++) {
                if(i != start && t[i] == t[start]) {
                    continue;
                }
                swap(t[i], t[start]);
                permute(t, start + 1, mid, res);
                swap(t[i], t[start]);
            }
        }
    };
```

* string(i->second / 2, i->first);可以输出多个相同字符

# 路径和

## 最小路径和

题目：https://leetcode-cn.com/problems/minimum-path-sum/

>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
>说明：每次只能向下或者向右移动一步。
>
>示例:
>
>输入:
>[
>  [1,3,1],
>  [1,5,1],
>  [4,2,1]
>]
>输出: 7
>解释: 因为路径 1→3→1→1→1 的总和最小。

solution:

```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        if(rows == 0)
            return 0;
        int columns = grid[0].size();
        for(int i=0; i<rows; i++) {
            for(int j=0; j<columns; j++) {
                if(i==0 && j==0) {
                    continue;
                }
                else if(i==0 && j!=0){
                    grid[i][j] = grid[i][j-1] + grid[i][j];
                }
                else if(i!=0 && j==0){
                    grid[i][j] = grid[i-1][j] + grid[i][j];
                }
                else {
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
                }
            }
        }
        return grid[rows-1][columns-1];
    }
};
```

分析：

* 状态定义：

  设 `dp `为大小` m×n` 矩阵，其中 `dp[i][j]` 的值代表直到走到 `(i,j) `的最小路径和。

* 转移方程：

  题目要求，只能向右或向下走，换句话说，当前单元格` (i,j) `只能从上方单元格 `(i-1,j)` 或左方单元格 `(i,j-1)`走到，因此只需要考虑矩阵左边界和上边界。

  走到当前单元格 `(i,j)` 的最小路径和` =` “从上方单元格 `(i-1,j) `与 从左方单元格 `(i,j-1)`走来的 两个最小路径和中较小的 ” `+`当前单元格值 `grid[i][j] `。具体分为以下 44 种情况：
  1) 当左边和上边都不是矩阵边界时： 即当$$i \neq 0,  j \not= 0$$时$$dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] $$
  2) 当只有上边是矩阵边界时： 只能从上面来，即当$$i = 0, j \not= 0$$时，$$dp[i][j] = dp[i][j - 1] + grid[i][j]；$$
  3) 当只有左边是矩阵边界时： 只能从左面来，即当$$i \not= 0, j = 0$$时， $$dp[i][j] = dp[i - 1][j] + grid[i][j]$$；
  4) 当左边和上边都是矩阵边界时： 即当$$i = 0, j = 0$$时，其实就是起点， $$dp[i][j] = grid[i][j];$$

* 初始状态：

  `dp`初始化即可，不需要修改初始 0值。

* 返回值：

  返回 `dp`矩阵右下角值，即走到终点的最小路径和。

* 其实我们完全不需要建立 `dp `矩阵浪费额外空间，直接遍历 $$grid[i][j]$$修改即可。这是因为：$$grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；$$原 `grid` 矩阵元素中被覆盖为 `dp` 元素后（都处于当前遍历点的左上方），**不会再被使用到**。
* 复杂度分析：
  时间复杂度 $$O(M \times N) $$： 遍历整个 `grid`矩阵元素。
  空间复杂度 $$O(1)$$ ： 直接修改原矩阵，不使用额外空间。

## 不同路径

题目：https://leetcode-cn.com/problems/unique-paths/

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>问总共有多少条不同的路径？
>
>例如，上图是一个7 x 3 的网格。有多少可能的路径？
>
>**示例 1:**
>
>```
>输入: m = 3, n = 2
>输出: 3
>解释:
>从左上角开始，总共有 3 条路径可以到达右下角。
>
>1. 向右 -> 向右 -> 向下
>2. 向右 -> 向下 -> 向右
>3. 向下 -> 向右 -> 向右
>```
>
>**示例 2:**
>
>```
>输入: m = 7, n = 3
>输出: 28
>```
>
>
>提示：
>
>1 <= m, n <= 100
>题目数据保证答案小于等于 2 * 10 ^ 9

solution:

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int count = 0;
        vector<int> arr(n, 1);  //必须是初始化为1
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(i==0 && j!=0){
                    arr[j] = arr[j-1];
                }
                else if(i!=0 && j==0){
                    arr[j] = arr[j];
                }
                else if(i!=0 && j!=0) {
                    arr[j] = arr[j-1] + arr[j];
                }
            }
        }
        return arr[n-1];
    }
};
```

分析：

* 利用动态规划, 借助一维数组,时间复杂度 $$O(M \times N) $$， 空间复杂度 $$O(N)$$ 

* 可以利用数学法，排列组合：$$C^{n-1}_{m+n-2}$$或者$$C^{m-1}_{m+n-2}=\frac{A^{n-1}_{m+n-2}}{(n-1)!}$$

  ```c++
  class Solution {
  public:
  int uniquePaths(int m, int n) {
  	if (m == 1 || n == 1)
  		return 1;
  	if (m > n)
  		swap(m, n);//保证m<=n
  	//计算阶乘：不用调用函数，节省空间
  	unsigned long long int temp = 1;
  	unsigned long long int result = 1;
  	for (int i = 1; i <= m-1 ; i++)
  	{
  		temp *= i;
  	}
  	for (int i = n; i <= m + n - 2; i++)
  	{
  		result *= i;
  	}
  	result = result / temp;
  	return result;
  }
  };
  ```

  即一共有m行n列，其中需要向下走m-1步，向右走n-1步，一共走m+n-2步。所以就是在m+n-2步中选出哪m-1步是向下走的，其余自动为向右走的步数。

## 不同路径II

题目：https://leetcode-cn.com/problems/unique-paths-ii/

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
>网格中的障碍物和空位置分别用 1 和 0 来表示。
>
>说明：m 和 n 的值均不超过 100。
>
>**示例 1:**
>
>```c++
>输入:
>[
>  [0,0,0],
>  [0,1,0],
>  [0,0,0]
>]
>输出: 2
>解释:
>3x3 网格的正中间有一个障碍物。
>从左上角到右下角一共有 2 条不同的路径：
>
>1. 向右 -> 向右 -> 向下 -> 向下
>2. 向下 -> 向下 -> 向右 -> 向右
>```
>
>

solution:

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        if(rows == 0)
            return 0;
        int columns = obstacleGrid[0].size();
        for(int i=0; i<rows; i++) {
            for(int j=0; j<columns; j++) {
                // 判断是否有障碍物，若有，当前点对结果贡献为0，直接置0即可。                	
                if(obstacleGrid[i][j] == 1){
                    obstacleGrid[i][j] = 0;
                    continue;
                }
                if(i==0 && j==0) {
                    obstacleGrid[i][j] = 1;// 将第一个格点赋初始值1；
                }
                else if(i==0 && j!=0){
                    obstacleGrid[i][j] = obstacleGrid[i][j-1];
                }
                else if(i!=0 && j==0){
                    obstacleGrid[i][j] = obstacleGrid[i-1][j];
                }
                else {
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];
                }
            }
        }
        return obstacleGrid[rows-1][columns-1];
    }
};
```

分析：

* 利用动态规划, 借助原数组,时间复杂度 $$O(M \times N) $$， 空间复杂度 $$O(1)$$ 

## 不同路径III

题目：https://leetcode-cn.com/problems/unique-paths-iii/

>在二维网格 grid 上，有 4 种类型的方格：
>
>1 表示起始方格。且只有一个起始方格。
>2 表示结束方格，且只有一个结束方格。
>0 表示我们可以走过的空方格。
>-1 表示我们无法跨越的障碍。
>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。
>
> **示例 1：**
>
>```
>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
>输出：2
>解释：我们有以下两条路径：
>
>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
>2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
>```
>
>**示例 2：**
>
>```
>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
>输出：4
>解释：我们有以下四条路径： 
>
>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
>2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
>3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
>4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
>```
>
>**示例 3：**
>
>```
>输入：[[0,1],[2,0]]
>输出：0
>解释：
>没有一条路能完全穿过每一个空的方格一次。
>请注意，起始和结束方格可以位于网格中的任意位置。
>```

solution:

* 方法一：回溯深度优先搜索

  思路与算法

  让我们尝试遍历每一个 0 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。

  ```C++
  class Solution {
      public:
      int count = 0;
      int direction[4][2]{{1,0},{-1,0},{0,1},{0,-1}};
      void dfs(vector<vector<int>>& grid, int x, int y, int n){
          if(x<0 || x>=grid.size() || y<0 || y>=grid[x].size() || grid[x][y] == -1) return;
          if(grid[x][y]==2){
              if(n == 0){
                  ++count;
              }
              return;
          }
          grid[x][y] = -1;
          for(int i = 0;i < 4;++i){
              int nx = x + direction[i][0];
              int ny = y + direction[i][1];
              dfs(grid,nx,ny,n-1);
          }
          grid[x][y] = 0;
          return;
      }
      int uniquePathsIII(vector<vector<int>>& grid) {
          int step = 1, x = 0, y = 0;
          for(int i=0; i<grid.size(); ++i)
              for(int j=0; j<grid[i].size(); ++j)
                  if(grid[i][j]==1) x=i, y=j;
                  else if(grid[i][j]==0) ++step;
          dfs(grid,x,y,step);
          return count;
      }
  };
  ```
  
  * 因为每一个无障碍方格都要通过一次，所以用step记录一共多少个无障碍方格，每遍历一次减一


* 方法二：动态规划

  思路与算法

  让我们定义 dp(r, c, todo) 为从 (r, c) 开始行走，还没有遍历的无障碍方格集合为 todo 的好路径的数量。可以使用一个与 方法一 类似的方法，并通过记忆化状态 (r, c, todo) 的答案来避免重复搜索。其他

## 二叉树中的最大路径和

题目：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china

>
>
>给定一个非空二叉树，返回其最大路径和。
>
>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
>
>示例 1:
>
>输入: [1,2,3]
>
>       1
>      / \
>     2   3
>
>输出: 6
>示例 2:
>
>输入: [-10,9,20,null,null,15,7]
>
>   ​     -10
>   ​      / \
>  ​	9  20
>    ​	     /  \
>   ​      15   7
>
>输出: 42

solution：

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
    class Solution {
    public:
        int res_max = INT_MIN;;
        int findMaxPath(TreeNode* root) {
            if(root == NULL)
                return 0;
            int lmax = max(findMaxPath(root->left), 0);
            int rmax = max(findMaxPath(root->right), 0);
            res_max = max(res_max, lmax + rmax + root->val);
            return max(lmax, rmax) + root->val;
        }
        int maxPathSum(TreeNode* root) {
            if(root == NULL) {
                    return 0;
            }
            findMaxPath(root);
            return res_max;
        }
    };
```

分析：

* 递归, findMaxPath 返回包含root节点值的向左或者向右中最长的路径值， lmax, rmax分别遍历不包含root节点值，然后更新res_max;
* 时间复杂度：$$O(N)$$ 其中 N 是结点个数。我们对每个节点访问不超过 2 次。
* 空间复杂度：$$O(N)$$ 其中 N 是结点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。

## 求根到叶子节点数字之和

题目：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/

>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
>
>例如，从根到叶子节点路径 1->2->3 代表数字 123。
>
>计算从根到叶子节点生成的所有数字之和。
>
>说明: 叶子节点是指没有子节点的节点。
>
>示例 1:
>
>```
>输入: [1,2,3]
>  1
> / \
>2   3
>输出: 25
>```
>
>解释:
>从根到叶子节点路径 1->2 代表数字 12.
>从根到叶子节点路径 1->3 代表数字 13.
>因此，数字总和 = 12 + 13 = 25.
>示例 2:
>
>```
>输入: [4,9,0,5,1]
>    4
>   / \
>  9   0
> / \
>5   1
>输出: 1026
>```
>
>
>
>解释:
>从根到叶子节点路径 4->9->5 代表数字 495.
>从根到叶子节点路径 4->9->1 代表数字 491.
>从根到叶子节点路径 4->0 代表数字 40.
>因此，数字总和 = 495 + 491 + 40 = 1026.

solution:

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int res = 0;
    int sumNumbers(TreeNode* root) {
      if(root == NULL) {
        return 0;
      }
      findSumNumbers(root, 0);
      return res;
    }
    void findSumNumbers(TreeNode* node, int sum) {
      if(node == NULL)
        return;
      sum = sum * 10 + node->val;
      if(node->left ==  NULL && node->right == NULL){
        res += sum;
        return;
      }
      findSumNumbers(node->left, sum);
      findSumNumbers(node->right, sum);   
    }
};
```

分析：

* DFS
* note: findSumNumbers return 可以先判断NULL值返回，然后更新sum，再判断叶子节点

## 最长同值路径

题目：

>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
>
>注意：两个节点之间的路径长度由它们之间的边数表示。
>
>示例 1:
>
>输入:
>
>              5
>             / \
>            4   5
>           / \   \
>          1   1   5
>
>输出:
>
>2
>示例 2:
>
>输入:
>
>              1
>             / \
>            4   5
>           / \   \
>          4   4   5
>
>输出:
>
>2
>注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。

solution:

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int res=0;
    int longestUnivaluePath(TreeNode* root) {
        findSameValueCount(root);
        return res;
    }
    int findSameValueCount(TreeNode* node) {
      if(node == NULL) {
        return 0;
      }
      int left = findSameValueCount(node->left);
      int right = findSameValueCount(node->right);
      int res_left = 0, res_right = 0;
      if(node->left != NULL && node->left->val == node->val) {
          res_left = left + 1;
      }
      if(node->right != NULL && node->right->val == node->val) {
          res_right = right + 1;
      }
      res = max(res, res_left + res_right);
      return max(res_left, res_right);
    }
};
```

分析：

* 递归， findSameValueCount 返回和当前节点相同值的最多边数， res_left = left + 1增加左节点这条边，利用res_left 是否为0来代表是否包含当前节点， 每一个节点都会更新res， 返回以当前节点出发的左右节点中最大的值
* 时间复杂度：$$O(N)$$，其中 N是树中节点数。我们处理每个节点一次。
* 空间复杂度：$$O(H)$$，其中 H 是树的高度。我们的递归调用栈可以达到 H 层的深度。

## 从叶结点开始的最小字符串

题目：https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/

>给定一颗根结点为 root 的二叉树，树中的每一个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。
>
>找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。
>
>（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 "ab" 比 "aba" 要小。叶结点是指没有子结点的结点。）
>
>示例 1：
>
>```
>输入：[0,1,2,3,4,3,4]
>输出："dba"
>```
>
>示例 2：
>
>```
>输入：[25,1,3,1,3,0,2]
>输出："adz"
>```
>
>
>示例 3：
>
>```
>输入：[2,2,1,null,1,0,null,0]
>输出："abc"
>```
>
>
>提示：
>
>给定树的结点数介于 1 和 8500 之间。
>树中的每个结点都有一个介于 0 和 25 之间的值。

solution：

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void helper(TreeNode* root, string& path, string& res) {
        if (root == NULL) return;
        if (root->left == NULL && root->right == NULL) {
            string s = path;
            s += root->val + 'a';
            reverse(s.begin(), s.end());
            if (!s.empty() && s < res) res = s;
            return;
        }
        path += root->val + 'a';
        helper(root->left, path, res);
        helper(root->right, path, res);
        path.pop_back();
    }
    string smallestFromLeaf(TreeNode* root) {
        string path;
        string res = "~";
        helper(root, path, res);
        return res;
    }
};
```

分析：

* 该方法为DFS

  

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    string ans = "z";
    void dfs(TreeNode* root, string s){
        s += char('a' + root->val);
        if(root->left == NULL && root->right == NULL){
            reverse(s.begin(), s.end());
            if(s < ans) ans = s;
        }
        if(root->left) dfs(root->left, s);
        if(root->right) dfs(root->right, s);
    }

    string smallestFromLeaf(TreeNode* root) {
        if(root==NULL) return ans;
        dfs(root, "");
        return ans;
    }
};
```

分析：

* DFS

# 单词接龙

## 单词接龙I

题目：https://leetcode-cn.com/problems/word-ladder/

>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：
>
>每次转换只能改变一个字母。
>转换过程中的中间单词必须是字典中的单词。
>说明:
>
>如果不存在这样的转换序列，返回 0。
>所有单词具有相同的长度。
>所有单词只由小写字母组成。
>字典中不存在重复的单词。
>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
>示例 1:
>
>输入:
>beginWord = "hit",
>endWord = "cog",
>wordList = ["hot","dot","dog","lot","log","cog"]
>
>输出: 5
>
>解释: 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
>     返回它的长度 5。
>示例 2:
>
>输入:
>beginWord = "hit"
>endWord = "cog"
>wordList = ["hot","dot","dog","lot","log"]
>
>输出: 0
>
>解释: endWord "cog" 不在字典中，所以无法进行转换。
>

solution: 

```C++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordList) {
        wordList.insert(endWord);
        queue<pair<string,int>> que;
        que.push(make_pair(beginWord, 1));
        wordList.erase(wordList.find(beginWord)); //绝
        while(!que.empty()){
            auto val = que.front();
            que.pop();
            if(val.first == endWord) return val.second; //!
            for(int i = 0; i < val.first.size(); i++) {
                string str = val.first;
                for(int j = 0; j < 26; j++) {
                    str[i] = 'a' + j;
                    if(wordList.count(str) == 1) {
                        que.push(make_pair(str, val.second + 1));
                        wordList.erase(str);
                    }
                }
            }
        }
        return 0;
    }
};
```

分析：

* (同源最短，Dijkstra，此题权值均为1，用BFS实现) 往队列添加元素一定要把set中元素删除
* 每次都换一位为其他26个字母比较浪费时间，可引入通配符，用**邻接表存储**（hashMap/unordered_map）

```C++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
      int wordLen = beginWord.size();
      int wordCount = wordList.size();
      unordered_map<string, vector<string>> dict;
      for(int i=0; i<wordCount; i++) {
        string word = wordList[i];
        for(int j=0; j<wordLen;j++) {
            string wordMatch = word;
            wordMatch[j] = '*';
            vector<string> temp;
            if(dict.count(wordMatch)) {
                temp = dict[wordMatch];
            }
            temp.push_back(word);
            dict[wordMatch] = temp;
        }
      }
      queue<pair<string, int>> que;
      unordered_map<string, bool> visited;
      que.push(make_pair(beginWord,1));
      visited[beginWord] = true;
      while(!que.empty()){
        auto val = que.front();
        que.pop();
        string word = val.first;
        int levels = val.second;
        for(int i=0; i<wordLen; i++) {
          string wordMatch = word;
          wordMatch[i] = '*';
          if(dict.count(wordMatch)) {
            vector<string> words = dict[wordMatch];
            for(auto word: words ){
              if(word == endWord) {
                return levels + 1;
              }
              if(!visited.count(word)) {
                que.push(make_pair(word, levels+1));
                visited[word] = true;
              }
            }
          }
        }
      }
      return 0;
    }
};
```

* 根据给定字典构造的图可能会很大，而广度优先搜索的搜索空间大小依赖于每层节点的分支数量。假如每个节点的分支数量相同，搜索空间会随着层数的增长指数级的增加。考虑一个简单的二叉树，每一层都是满二叉树的扩展，节点的数量会以 2 为底数呈指数增长。
* 如果使用两个同时进行的广搜可以有效地减少搜索空间。一边从 beginWord 开始，另一边从 endWord 开始。我们每次从两边各扩展一个节点，当发现某一时刻两边都访问了某一顶点时就停止搜索。这就是双向广度优先搜索，它可以可观地减少搜索空间大小，从而降低时间和空间复杂度。
* 双向搜索的结束条件是找到一个单词被两边搜索都访问过了。

双向BFS

```C++
class Solution {
private:
    int wordLen = 0;
    unordered_map<string, vector<string>> dict;
public:
    int visit(queue<pair<string, int>>& que, unordered_map<string, int> &visited, unordered_map<string, int> &anoVisited){
        string word = que.front().first;
        int levels = que.front().second;
        que.pop();
        for(int i=0; i<wordLen; i++) {
            string wordMatch = word.substr(0,i) + '*' + word.substr(i+1, wordLen);
            for(auto word: dict[wordMatch] ){
                if(anoVisited[word])
                    return anoVisited[word] + levels;
                if(!visited[word]) {
                    que.push(make_pair(word, levels+1));
                    visited[word] = levels + 1;
                }
            }
          }
        return -1;
    }
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
      wordLen = beginWord.size();
      bool flag = false;
      for(auto word: wordList) {
        for(int i=0; i<wordLen;i++) {
            string wordMatch = word.substr(0,i) + '*' + word.substr(i+1, wordLen);
            dict[wordMatch].push_back(word);
        }
        if(word == endWord) {
            flag = true;
        }
      }
      if(!flag)   
          return 0;//endWord不在wordList里
      queue<pair<string, int>> begin_que, back_que;
      unordered_map<string, int> beginVisited, endVisited;
      begin_que.push(make_pair(beginWord,1));
      back_que.push(make_pair(endWord,1));
      beginVisited[beginWord] = 1;
      endVisited[endWord] = 1;
      while(!begin_que.empty() && !back_que.empty()) {
        int ans = visit(begin_que, beginVisited, endVisited);
        if(ans != -1)
          return ans;
        ans = visit(back_que, endVisited, beginVisited);
        if(ans != -1)
          return ans;
      }
      return 0;
    }
};
```

* 千万注意 visit函数参数queue<pair<string, int>>& que 要加&传址，要不然就错了。
* 时间复杂度O(M×N)，其中 MM 是单词的长度 N是单词表中单词的总数。与单向搜索相同的是，找到所有的变换需要 M * N次操作。但是搜索时间会被缩小一半，因为两个搜索会在中间某处相遇。
  空间复杂度O(M×N)，要在 dict 字典中记录每个单词的 M通用状态，这与单向搜索相同。但是因为会在中间相遇，所以双向搜索的搜索空间变小

## 单词接龙 II

题目：https://leetcode-cn.com/problems/word-ladder-ii/

>给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则：
>
>每次转换只能改变一个字母。
>转换过程中的中间单词必须是字典中的单词。
>说明:
>
>如果不存在这样的转换序列，返回一个空列表。
>所有单词具有相同的长度。
>所有单词只由小写字母组成。
>字典中不存在重复的单词。
>你可以假设 beginWord 和 endWord 是非空的，且二者不相同。
>**示例 1:**
>
>```
>输入:
>beginWord = "hit",
>endWord = "cog",
>wordList = ["hot","dot","dog","lot","log","cog"]
>
>输出:
>[
>  ["hit","hot","dot","dog","cog"],
>  ["hit","hot","lot","log","cog"]
>]
>```
>
>**示例 2:**
>
>```
>输入:
>beginWord = "hit"
>endWord = "cog"
>wordList = ["hot","dot","dog","lot","log"]
>
>输出: []
>```
>
>
>
>解释: endWord "cog" 不在字典中，所以不存在符合要求的转换序列。
>

solution：

```C++
class Solution {
public:
    unordered_map<string, set<pair<string, int>>> hash;
    vector<vector<string>> result;
    void dfs(set<pair<string, int>> st, vector<string> vec) {
        for(auto val: st) {
            vec.push_back(val.first);
            if(hash.count(val.first)==0)
            {
                reverse(vec.begin(), vec.end());
                return result.push_back(vec);
            }
            dfs(hash[val.first], vec);
            vec.pop_back();
        }
    }
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
      int wordLen = beginWord.size();
      int wordCount = wordList.size();
      unordered_map<string, vector<string>> dict;
      for(int i=0; i<wordCount; i++) {
        string word = wordList[i];
        for(int j=0; j<wordLen;j++) {
            string wordMatch = word;
            wordMatch[j] = '*';
            vector<string> temp;
            if(dict.count(wordMatch)) {
                temp = dict[wordMatch];
            }
            temp.push_back(word);
            dict[wordMatch] = temp;
        }
      }
      queue<pair<string, int>> que;
      unordered_map<string, bool> visited;
      que.push(make_pair(beginWord,1));
      visited[beginWord] = true;
      while(!que.empty()){
        auto val = que.front();
        que.pop();
        string word = val.first;
        int levels = val.second;
        for(int i=0; i<wordLen; i++) {
          string wordMatch = word;
          wordMatch[i] = '*';
          if(dict.count(wordMatch)) {
            vector<string> words = dict[wordMatch];
            for(auto word: words ){
              if(!visited.count(word)) {
                que.push(make_pair(word, levels+1));
                visited[word] = true;
                hash[word].insert(val);
              } else if(hash.count(word) && hash[word].begin()->second == val.second){
                    hash[word].insert(val);
                }
            }
          }
        }
      }
      dfs(hash[endWord], vector<string>{endWord});
      return result;
    }
};
```

分析：

* 设置一个hash表用来存储一个字符串的父结点集合, 这样C不在字典中再去查hash表看C是否在hash表中,如果在的话并且C的父结点层次和B一样, 那么就将B也加入到C的父结点结合中去. 可以知道, 一个字符串的父结点集合的距离起点的距离必然是相等的, 也就是说他们都是最短距离.最后遍历完所有的点之后, 再用DFS从终点往前找出所有集合即可.)

## 矩阵中的路径

题目：

>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
>
>[["a","b","c","e"],
>["s","f","c","s"],
>["a","d","e","e"]]
>
>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
>
>
>
>**示例 1**：
>
>```
>输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
>输出：true
>```
>
>**示例 2：**
>
>```
>输入：board = [["a","b"],["c","d"]], word = "abcd"
>输出：false
>```
>
>

solutions:

```C++
class Solution {
public:
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, -1, 0, 1};
    bool exist(vector<vector<char>>& board, string word) {
        bool found = false;
        int rows = board.size();
        if(rows <=0)
            return found;
        int columns = board[0].size();
        vector<vector<int>> visited(rows, vector<int>(columns, 0));
        for(int i=0;i<rows;i++) {
            for(int j=0;j<columns;j++) {
                if(word[0] == board[i][j]) {
                    if(dfs(board, visited, i, j, word.substr(1))) {
                        found = true;
                        return found;
                    }
                }
            }
        }
        return found;
    }

    bool dfs(vector<vector<char>>& board, vector<vector<int>>& visited, int row, int column, string word) {
        if(word == "")
            return true;
        visited[row][column] = 1;
        for(int i=0; i<4;i++) {
            int x = row + dx[i];
            int y = column + dy[i];
            if(x<0 || x >= board.size() || y<0 || y >= board[0].size() || visited[x][y] || board[x][y] != word[0]) {
                continue;
            } else if(dfs(board, visited, x, y, word.substr(1))){
                return true;
            }
        }
        visited[row][column] = 0;
        return false;
    }
};
```

分析：

* DFS+ 回溯法
* 初始化矩阵为0：vector<vector<int>> visited(rows, vector<int>(columns, 0));

# 买卖股票

```
一、穷举框架
首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。

递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。

而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。


for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：


dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <= K
n 为天数，大 K 为最多交易数
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

二、状态转移框架
现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。



通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：


dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,           选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。
这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。


dp[-1][k][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
dp[-1][k][1] = -infinity
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
把上面的状态转移方程总结一下：


base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。

```



## [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

题目：

>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
>
>注意：你不能在买入股票前卖出股票。
>
> 
>
>示例 1:
>
>输入: [7,1,5,3,6,4]
>输出: 5
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
>示例 2:
>
>输入: [7,6,4,3,1]
>输出: 0
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

solutions:

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()<1)
            return 0;
        int minV = prices[0];
        int res = 0;
        for(int i=1;i<prices.size();i++) {
            res = max(res, prices[i] - minV);
            minV = min(minV, prices[i]);
        }
        return res;
    }
};
```



## [ 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

题目：

>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> 
>
>示例 1:
>
>输入: [7,1,5,3,6,4]
>输出: 7
>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
>示例 2:
>
>输入: [1,2,3,4,5]
>输出: 4
>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>示例 3:
>
>输入: [7,6,4,3,1]
>输出: 0
>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

solutions:

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() < 1)
            return 0;
        int ret = 0;
        for(int i = 0; i< prices.size() - 1; i++)
        {
            if(prices[i+1] - prices[i] > 0)
                ret += prices[i+1] - prices[i];
        }
        return ret;
    }
};
```

* 每次价格上涨的利润之和会是一个波谷到波峰的差值

## [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
>
>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>示例 1:
>
>输入: [3,3,5,0,0,3,1,4]
>输出: 6
>解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
>     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
>示例 2:
>
>输入: [1,2,3,4,5]
>输出: 4
>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
>示例 3:
>
>输入: [7,6,4,3,1] 
>输出: 0 
>解释: 在这个情况下, 没有交易完成, 所以最大利润为 0
>
>

solutions:

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {        
        int minPrice1 = INT_MAX;         
        int maxProfit1 = 0;                        
        int maxProfitAfterBuy = INT_MIN; 
        int maxProfit2 = 0;                        
        for(int price : prices) {
            // 1.第一次最小购买价格
            minPrice1  = min(minPrice1,  price);
            // 2.第一次卖出的最大利润
            maxProfit1 = max(maxProfit1, price - minPrice1);
            // 3.第二次购买后的剩余净利润
            maxProfitAfterBuy  = max(maxProfitAfterBuy,  maxProfit1 - price );
            // 4.第二次卖出后，总共获得的最大利润（第3步的净利润 + 第4步卖出的股票钱）
            maxProfit2 = max(maxProfit2, price + maxProfitAfterBuy);
        }
        return maxProfit2;
    }
};
```

## [买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

题目：

>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
>
>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
>
>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
>示例 1:
>
>输入: [2,4,1], k = 2
>输出: 2
>解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
>示例 2:
>
>输入: [3,2,6,5,0,3], k = 2
>输出: 7
>解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

solutions:

```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(k >= prices.size()/2)
        {
            int sum = 0;
            for(int i = 1; i < prices.size(); i++)
            {
                int val = prices[i] - prices[i - 1];
                sum += (val > 0? val: 0);
            }
            return sum;
        }
        vector<vector<vector<int>>> dp(k + 1, vector<vector<int>>(prices.size() + 1, vector<int>(2, 0)));
        for(int t = 0; t <= k; t++)
            dp[t][0][1] = -1000000;
        for(int i = 0; i < prices.size(); i++)
            dp[0][i][1] = -1000000;

        for(int t = 1; t <= k; t++) {
            for(int i = 1; i <= prices.size(); i++) {
                dp[t][i][0] = max(dp[t][i - 1][0], dp[t][i - 1][1] + prices[i - 1]);
                dp[t][i][1] = max(dp[t][i - 1][1], dp[t - 1][i - 1][0] - prices[i - 1]);
            }
        }
        return dp[k][prices.size()][0];
    }
};
```

* 还有二维，一维解法

## [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
>
>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>示例:
>
>输入: [1,2,3,0,2]
>输出: 3 
>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

solutions:

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int sellProfit = 0, buyProfit = INT_MIN;
        int preSellProfit = 0; // 代表 dp[i-2][0]
        for (int i = 0; i < n; i++) {
            int temp = sellProfit;
            sellProfit = max(sellProfit, buyProfit + prices[i]);
            buyProfit = max(buyProfit, preSellProfit - prices[i]);
            preSellProfit = temp;
        }
        return sellProfit;
    }
};
```



# 动态规划

## 把数字翻译成字符串

题目：

>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
>
> 
>
>示例 1:
>
>输入: 12258
>输出: 5
>解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

solution：

```C++
class Solution {
public:
    int translateNum(int num) {
        int res =1, first=1, second=1;
        string s = to_string(num);
        for(int i=2; i<=s.size(); i++) {
            string temp = s.substr(i-2, 2);
            res = (temp >= "10" && temp <="25") ? first + second : first;
            second = first;
            first = res;
        }
        return res;
    }
};
```

分析：

* 动态规划+滚动数组，因为滚动数组只需要维护两个变量，所以可以省略
* 时间复杂度 O(N)： N 为字符串 ss 的长度（即数字 num 的位数 $$log(num)$$ ），其决定了循环次数。
  空间复杂度 O(N)： 字符串 ss 使用 O(N)大小的额外空间。

<img src=数字转字符串动态规划.png style="zoom: 25%;" />

* 递归也可以完成，可以利用标记数组剪枝

## 打家劫舍

题目：https://leetcode-cn.com/problems/house-robber/

>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> 
>
>示例 1：
>
>输入：[1,2,3,1]
>输出：4
>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>示例 2：
>
>输入：[2,7,9,3,1]
>输出：12
>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
>
>

solutions:

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int size = nums.size();
        if(size == 0) {
            return 0;
        } else if(size == 1) {
            return  nums[0];
        }
        int first = max(nums[0], nums[1]);
        int second = nums[0];
        for(int i=2; i< size; i++) {
            int temp = max(nums[i] + second, first);
            second = first;
            first = temp;
        }
        return first;
    }
};
```

分析：

* 动态规划+滚动数组
* 如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 $$k~(k>2)$$间房屋，有两个选项

  1）偷窃第 k 间房屋，那么就不能偷窃第 $$k−1 $$间房屋，偷窃总金额为前$$k−2$$ 间房屋的最高总金额与第 k 间房屋的金额之和。

  2）不偷窃第 k 间房屋，偷窃总金额为前$$k−1$$ 间房屋的最高总金额。
* 时间复杂度：$$O(n)$$，其中 n 是数组长度。只需要对数组遍历一次。
* 空间复杂度：$$O(1)$$。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 $$O(1)$$。

## 打家劫舍II

题目：https://leetcode-cn.com/problems/house-robber-ii/

>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
>
>**示例 1:**
>
>```
>输入: [2,3,2]
>输出: 3
>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
>```
>
>**示例 2:**
>
>```
>输入: [1,2,3,1]
>输出: 4
>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>     偷窃到的最高金额 = 1 + 3 = 4 。
>```

分析：

* 这个题与上一个题的区别在于，房屋是环形的，这意味着，第一个房间和最后一个房间不能同时偷窃。这就意味着，将原来的问题转化为两个子问题：偷窃1 ~ n-1个房间的最大值以及偷窃 2~n 个房间的最大值。最终，取二者的最大值即为解因此可以对上一个问题进行两次dp即可。

  ```C++
  class Solution {
  public:
      int rob(vector<int>& nums) 
      {
          int length=nums.size();
          if(length==0) return 0;
          if(length==1) return nums[0];
          vector<int> dp(length+1);
          dp[0]=nums[0];
          dp[1]=max(nums[0],nums[1]);
          for(int i=2;i<length-1;i++)
          {
              dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
          }
          int result=dp[length-2];
          dp[0]=0;dp[1]=nums[1];
          for(int i=2;i<length;i++)
          {
              dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
          }
          result=max(result,dp[length-1]);
          return result;
      }
  };
  ```

  还有一种循环解决的办法，就是用两个DP数组，记录两种状态：

  ```C++
  class Solution {
  public:
      int rob(vector<int>& nums) {
          int size = nums.size();
          if(size == 0) {
              return 0;
          } else if(size == 1) {
              return nums[0];
          }
          vector<int> dpA(size+1), dpB(size+1);
          for(int i=2; i<= size; i++) {
              dpA[i] = max(dpA[i-2]+nums[i-2], dpA[i-1]);
              dpB[i] = max(dpB[i-2]+nums[i-1], dpB[i-1]);
          }
          return max(dpA[size], dpB[size]);
      }
  }
  ```

## 打家劫舍 III

题目：https://leetcode-cn.com/problems/house-robber-iii/

>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
>
>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
>
>示例 1:
>
>输入: [3,2,3,null,3,null,1]
>
>    		 3
>    		/ \
>    	 2   3
>     	 \   \ 
>     	  3   1
>	输出: 7 
>	解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
>	示例 2:
>输入: [3,4,5,1,3,null,1]
>
>        3
>            / \
>           4   5
>          / \   \ 
>         1   3   1
>         输出: 9
>    解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
>

solutions:

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        auto ret = dfs(root);
        return max(ret[0], ret[1]);
    }

    vector<int> dfs(TreeNode* root) {
        if (!root) return {0 ,0};
        auto ret1 = dfs(root->left);
        auto ret2 = dfs(root->right);
        vector<int> result(2);
        result[0] = max(ret1[0], ret1[1]) + max(ret2[0], ret2[1]);
        result[1] = root->val + ret1[0] + ret2[0];
        return result; 
    }
};
```

分析：

* 从暴力递归+最优子结构 -》 加入记忆化来优化 -》消除后效性（https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/）
* 树的问题，很多时候采用**后序遍历**。

# DFS

## [复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

题目：

>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
>
>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 '.' 分隔。
>
>示例:
>
>输入: "25525511135"
>输出: ["255.255.11.135", "255.255.111.35"

solutions:

```C++
class Solution {
public:
    bool isValid(string s) {
        int n = stoi(s);
        if(n>255 || (s.size()>1 && s[0]=='0'))
            return false;
        return true;
    }
    void dfs(string& s, vector<string>& path, int pos, vector<string>& res) {
        int maxLen = (4-path.size())*3;
        if(s.size() - pos >maxLen) return;
        if(path.size()==4 && pos == s.size()) {
            string ip="";
            for(int i=0; i< 4;i++) {
                ip += path[i];
                if(i!=3) ip += '.';
            }
            res.push_back(ip);
            return;
        }
        for(int i=pos; i<s.size() && i <= pos+2;i++) {
            string ip = s.substr(pos, i-pos+1);
            if(!isValid(ip)) continue;
            path.push_back(ip);
            dfs(s, path, i+1, res);
            path.pop_back();
        }
        return;
    }
    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        vector<string> path;
        dfs(s, path, 0, res);
        return res;
    }
};
```

* DFS深度搜索思路，数值>255非法，以零开头长度大于等于2非法；
* 不同于常规回溯思路，同层只用最多遍历3个数字，依次查看是否满足数值要求；
* 各段的数值状态也是分段存储的，互不干涉，使用vector<string> path来存储；

# 滑动窗口

模板：

```C++
unordered_map/unordered_set用于发现有没有或者个数
int left=0, right=0; int cnt;
while(right<data.size()) {
    map[right++]++;
    if(第一次出现)
        cnt++;
    while(cnt>k) {
        map[left]--;
        if(剩最后一个data[left]) {
            cnt--;
            left++;
        }
    }
    if(cnt == k) {

    }
    更新res;
}
```

[无重复字符的最长子串](# 无重复字符的最长子串)

[至多包含两个不同字符的最长子串](# 至多包含两个不同字符的最长子串)

[K 个不同整数的子数组](# K 个不同整数的子数组)



# 单调栈

## [链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/)

题目：

>给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。
>
>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。
>
>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。
>
>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。
>
> 
>
>示例 1：
>
>输入：[2,1,5]
>输出：[5,5,0]
>示例 2：
>
>输入：[2,7,4,3,5]
>输出：[7,0,5,5,0]
>示例 3：
>
>输入：[1,7,5,1,9,2,5,1]
>输出：[7,9,9,9,0,5,0,0]

solution:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> nextLargerNodes(ListNode *head){
        int count = 0; //计数，作为下标
        vector<int> result;
        stack<pair<int, int>> st; //first为val，second为下标
        while (head) {
            result.push_back(0); //给result数组后面+0，1为保证长度，2是默认值（后无更大的值的话）为0
            while (!st.empty() && head->val > st.top().first) //栈不为空且head指针的val值大于栈顶的元素的值
            {
                result[st.top().second] = head->val; //result数组修改，满足题意要求的最大值，然后出栈，继续循环
                st.pop();
            }
            st.push(make_pair(head->val, count++)); //count++计数
            head = head->next; //下一个节点
        }
        return result;
    }
};
```

* 单调递减栈， 时间复杂度$$O(N)$$, 空间复杂度复杂度$$O(N)$$

## [移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

题目：https://leetcode-cn.com/problems/remove-k-digits/

>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
>
>注意:
>
>num 的长度小于 10002 且 ≥ k。
>num 不会包含任何前导零。
>示例 1 :
>
>输入: num = "1432219", k = 3
>输出: "1219"
>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
>示例 2 :
>
>输入: num = "10200", k = 1
>输出: "200"
>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
>示例 3 :
>
>输入: num = "10", k = 2
>输出: "0"
>解释: 从原数字移除所有的数字，剩余为空就是0。
>
>

solutions:

```C++
class Solution {
public:
    string removeKdigits(string num, int k) {
        stack<pair<char, int>> st;
        string res;
        int count = 0;
        for(auto c : num) {
            res[count] = c;
            while(k && !st.empty() && st.top().first > c) {
                res[st.top().second] = c;
                st.pop();
                k--;
                count--;
            }
            st.push({c, count++});
        }
        while (!res.empty() && res[0] == '0') {
            res = res.substr(1);
        }
        return res.empty() ? "0" : res;
    }
};
```

* 单调栈的妙用：st.push({c, count++});加入字符及当时的index位置

# 前缀和

**什么是前缀和**

前缀和，顾明思议就是所有数组前缀的和，如果用数组pre表示，那么pre[i]就是nums[0]~nums[i]的和

**前缀和应用**

主要针对数组中**连续子数组的和**，就考虑前缀和

那么[j,i]之间的和就是pre[i] - pre[j-1]

对于求解连续子数组和为k的个数的问题，
以i结尾的和为k的连续子数组就是找到j使得pre[j-1] = pre[i] - k
也就是前缀和里面有多少个是pre[i] - k

如何快速的求解pre[j-1]呢？如果想实现O(1)的时间复杂度，就需要将pre的数据存储到map，map的key为pre[x]，value为出现该前缀和的数量。

## [统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)

题目：

>给你一个整数数组 nums 和一个整数 k。
>
>如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
>
>请返回这个数组中「优美子数组」的数目。
>
> 
>
>示例 1：
>
>输入：nums = [1,1,2,1,1], k = 3
>输出：2
>解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
>示例 2：
>
>输入：nums = [2,4,6], k = 1
>输出：0
>解释：数列中不包含任何奇数，所以不存在优美子数组。
>示例 3：
>
>输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
>输出：16

solutions:

```C++
class Solution {
public:
    int numberOfSubarrays(vector<int>& nums, int k) {
        int res =0;
        vector<int> preCount;
        preCount.resize(nums.size() + 1, 0);
        preCount[0] = 1;
        int sum = 0;
        for(int i=0; i<nums.size(); i++) {
            sum += nums[i] & 1;
            if(sum >= k) {
                res += preCount[sum-k];
            }
            preCount[sum]++;
        }
        return res;
    }
};
```

分析：

* sum为pre[i-1], preCount 为维护前缀和与前缀和的个数的存储单元
* 核心代码：sum += nums[i] & 1;处理pre[i]和pre[i-1]的逻辑， if(sum >= k) {res += preCount[sum-k];计算res

## [每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)

题目：

>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
>
> 
>
>示例 1：
>
>输入：s = "eleetminicoworoep"
>输出：13
>解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
>示例 2：
>
>输入：s = "leetcodeisgreat"
>输出：5
>解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
>示例 3：
>
>输入：s = "bcbcbc"
>输出：6
>解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。

solutions:

```C++
 class Solution {
public:
    int findTheLongestSubstring(string s) {
        vector<int> pos(1<<5, -1);
        int res = 0;
        int status =0;
        pos[0] = 0;
        for(int i=0; i<s.size();i++) {
            if(s[i] == 'a') {
                status ^= 1<<0;
            } else if(s[i] == 'e') {
                status ^= 1<<1;
            } else if (s[i] == 'i') {
                status ^= 1<<2;
            } else if(s[i] == 'o') {
                status ^= 1<<3;
            } else if(s[i] == 'u') {
                status ^= 1<<4;
            }
            if(pos[status] != -1) {
                res = max(res, i+1-pos[status]);
            } else {
                pos[status] = i+1;//+1考虑的是包括i=0的字符
            }
        }
        return res;
    }
};
```

分析：

* #### 前缀和 + 状态压缩

* 异或巧妙的反应了奇偶性

* 假如到第 i个位置，u o i e a 出现的奇偶性分别为 1 1 0 0 1，那么我们就可以将其压成一个二进制数 (11001)_2=25作为它的状态。这样我们就可以将 55 个元音字母出现次数的奇偶性压缩到了一个二进制数中，且连续对应了二进制数的 [(00000)_,(11111)] 的范围，转成十进制数即 [0,31][0,31]

* 偶数这个条件其实告诉了我们，对于满足条件的子串而言，两个前缀和 pre[i][k]pre[i][k] 和 pre[j][k]pre[j][k] 的奇偶性一定是相同的，因为小学数学的知识告诉我们：奇数减奇数等于偶数，偶数减偶数等于偶数。因此我们可以对前缀和稍作修改，从维护元音字母出现的次数改作维护元音字母出现次数的奇偶性。这样我们只要实时维护每个元音字母出现的奇偶性，那么 s[j+1,i]s[j+1,i] 满足条件当且仅当对于所有的 kk，pre[i][k]pre[i][k] 和 pre[j][k]pre[j][k] 的奇偶性都相等，此时我们就可以利用哈希表存储每一种奇偶性（即考虑所有的元音字母）对应最早出现的位置，边遍历边更新答案。




# 并查集

##  孤岛

[Number of Islands II](##Number of Islands II)



# 二分法

## 旋转数组

[寻找旋转排序数组中的最小值](##寻找旋转排序数组中的最小值)

[寻找旋转排序数组中的最小值 II](##寻找旋转排序数组中的最小值 II)

# 排序

>排序 （稳定性是看两个相等的数，一次排序后相对位置是否变化, 稳定的排序有：冒泡，直接插入，二分法插入排序 ，归并，桶，基数，计数，其他的不稳定）
>    //https://blog.csdn.net/u010305706/article/details/51207444
>    //https://www.cnblogs.com/fivestudy/p/10212306.html
>    //九大排序 :1）插入排序：
>    //             直接插入排序（从后往前，稳定，最好n,最差n的平方，平均时间复杂度n的平方），
>    //             希尔排序，（逐渐分组排序，最后增量为1，不稳定，平均时间复杂度nlogn）
>    //             二分法插入排序 (从后往前，稳定，与正反序无关，移动和直接插入相同，查询位置平均少，平均时间复杂度O(nlogn))
>    //        2）交换排序：
>    //             冒泡排序 （大数往下沉，小数往上冒，稳定，正序复杂度n，反序n的平方，平均时间复杂度n的平方）
>    //             快速排序 【递归调用导致logn空间复杂度】（基数，小于基数放左边，大于基数放右边，不稳定，时间复杂度为nlogn,数比较大的时候用比较合适，基本正序的时候反而不好用）
>    //        3) 选择排序：
>    //             简单选择排序 (选择最小的放到最前面，不稳定，时间复杂度n的平方)
>                        //不稳定理解5 8 5 2 9, 2会和第一个5交换
>    //             堆排序 （建立堆，不断剔除最大数，不稳定，最坏nlogn,建立堆需要多判断，不宜记录数小的文件）
>    //        4) 归并排序：【空间复杂度n】（分组，子序列先排序再合并，稳定，时间复杂度nlogn，常用于总体无序，子项相对有序, 实现merge时需要用到辅助数组）
>    //        5) 基数排序：（从最低位，按照位排序，稳定，稳定性d(n+r)，d位数，r基数）
>    //        6）计数排序
>    //        7) 桶排序

## 希尔排序

```C++
void shellsort(int a[],int n) {
	//分组：以数组长度/2为起始分组点
	//循环结束执行delta/2：再一次分组
	for(int delta=n/2;delta>0;delta/=2) {
		//组内排序：排序方式为插入方式
		//i++:就到了下一组
		for(int i=delta;i<n;i++) {
			int temp=a[i];
			int j=i-delta;
			while(j>=0 && temp<a[j]) {
			   a[j+delta]=a[j];//将在a[i]前且比temp的值大的元素向后移动一位
			}
			a[j+delta]=temp;
		}
	}
}
```

## 堆排序

```C++
//堆排序：https://www.cnblogs.com/chengxiao/p/6129630.html
//其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。
建堆从最后一个非叶子结点开始length/2-1

    
#define left(x) 2*x+1;//获得左节点在数组中的下标
#define right(x) 2*(x+1);//获得右节点在数组中的下标
 void MaxHeapify(int* a,int i,int low,int high)//输入为要被排序的数组和根节点，数组a当中被维护的那一部分的下标low，high
 {
     int l = left(i);//计算下标为i的节点的左子节点
     int r = right(i);//计算下标为i的节点的右子节点
     int largest=i;//保存i,l,r(即i和它的左右子节点)之间的最大数的下标
     int temp;//交互数组中的数所使用的临时变量
     //找到三个数当中最大的那个数，将最大的那个数和i进行互换
     if (l<=high && a[l]>a[i]) {
         largest = l;
     }     
     if (r<=high && a[r]>a[i]) {
         largest = r;
     }
     if (largest != i) {
         temp = a[i];
         a[i] = a[largest];
         a[largest] = temp;
         MaxHeapify(a, largest,low,high);//交换有可能破坏子树的最大堆性质，所以对所交换的那个子节点进行一次维护，而未交换的那个子节点，根据我们的假设，是保持着最大堆性质的。
     }
 }
 void BuildMaxHeap(int* a,int length) {
     for (int i = length/2 - 1; i >= 0; i--) {
         MaxHeapify(a, i, 0, length - 1);
     }
 }
堆排序函数
 void HeapSort(int a[],int length)
 {
     int temp;
     BuildMaxHeap(a,length);
     for (int i = length - 1; i >= 1; i--)
     {
         //交换根节点和数组的最后一个节点
         temp = a[i];
         a[i] = a[0];
         a[0] = temp;
         MaxHeapify(a, 0, 0, i-1);//维护从下标为i-1到0的子数组
     }
 }
```

* 因为最大堆为完全二叉树结构，因此A[n/2+1],……,A[n]是最大堆的叶子节点。每个叶子节点本身就是一个最大堆，所以我们就要从A[n/2]~A[1]逐步维护这个最底层的最大堆。

## 归并

```C++
//归并排序
void merge_sort(int *a, int left, int right)
{
    if(left<right){
         int middle = (left+right)/2;
         //对左边进行递归
         mergeSort(a, left, middle);
         //对右边进行递归
         mergeSort(a, middle+1, right);
         //合并
         merge(a,left,middle,right);
}

void merge(int *a, int middle, int left,int right)
{
    int tmparr[a.length];
    int mid = middle+1; //右边的起始位置
     int tmp = left;
     int third = left;
     while(left<=middle && mid<=right){
         //从两个数组中选取较小的数放入中间数组
         if(a[left]<=a[mid]){
             tmparr[third++] = a[left++];
         }else{
             tmparr[third++] = a[mid++];
         }
     }
     //将剩余的部分放入中间数组
     while(left<=middle){
         tmparr[third++] = a[left++];
     }
     while(mid<=right){
         tmparr[third++] = a[mid++];
     }
     //将中间数组复制回原数组
     while(tmp<=right){
         a[tmp] = tmparr[tmp++];
     }
}
```

## 快排

```C++
//8 快排 (选一个基数，通常选第一个或者最后一个，利用前后双指针将小于基数的数放到左边，大于基数的数放到右边，再把基数放到对应的位置，利用迭代完成，递归次数log2n，第一次partition 为n)
//最差情况一边倒  (n-1)+(n-2)+…+2+1= O(n^2) 时间。
#include<stdio.h>
#include<string.h>
int partition(int data[], int low, int high)
{
    if(data == NULL || low < 0)
    {
        printf("internal error\n");
    }
    int temp = data[low];
    while(low < high){
        while((low < high) && (data[high] >= temp)){
            high--;
        }
        data[low] = data[high];
        while((low < high) && (data[low] <= temp)){
            low++;
        }
        data[high] = data[low];

    }
    data[low] = temp;
    return low;
}

void QuickSort(int data[], int start, int end)
{
    if(start < end){
        int index = partition(data, start, end);
        QuickSort(data, start, index - 1);
        QuickSort(data, index + 1, end);
    }
}

int main()
{
    int a[14] = {49,38,65,97,76,13,27,49,78,34,12,64,1,8};
    int i;
    printf("quick sort before\n");
    for(i = 0;i<14;i++){
            printf("%d\t",a[i]);
    }

    QuickSort(a, 0, 13);
    printf("quick sort after\n");
    for(i = 0;i<14;i++){
            printf("%d\t",a[i]);
    }

}
```

# 数学

## 2出现的次数

题目：https://leetcode-cn.com/problems/number-of-2s-in-range-lcci/

>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。
>
>示例:
>
>输入: 25
>输出: 9
>解释: (2, 12, 20, 21, 22, 23, 24, 25)(注意 22 应该算作两次)
>提示：
>
>n <= 10^9
>

solution：

```C++
class Solution {
public:
    int numberOf2sInRange(int n) {
        int refer = 2;
        int count = 0;
        long ten = 1;
        int current, high, low;
        while(n/ten != 0) {
            current = (n / ten) % 10;
            high = n / (ten*10);
            low = n % ten;
            if(current > refer) {
                count += (high + 1) * ten;
            } else if(current < refer) {
                count += high * ten;
            } else {
                count += high * ten + low + 1;
            }
            ten *= 10;
        }
        return count;
    }
};
```

分析：

* 算法核心思想是分别统计每位（个、十、百、千位等等）出现待查数（比如这道题的2）的次数，然后求和，实现O(n)复杂度

* 比如我们要统计下面三个数百位上出现2的次数，无非就三种情况，大于2，小于2，等于2

> **情况1**（百位大于2），如：12313
> 要想百位出现2，由于当前百位是3，那么最终的次数只依赖于更高位
> 00200-00299 100个数
> 01200-01299 100个数
> ...
> 12200-12299 100个数
> 所有百位出现2的总个数为从0到12 共13个100，即13*100=1300
> 即百位3的左侧那部分12加上1共13个百位为1的总数，从0到12共13个数吧，手指头加上脚指头数一数哈，同样，从200到299共100个数哈
> 结论1：当前位大于2=（当前位的左边部分+1）*10**当前位的右半部分的长度 ，这里就是（12+1）*10**len('13') 那要是左半边为空即开头呢，如345百位是3也大于2，左边为空呢，为空就是0喽，直接就是(0+1)*10**len('45')， 也就是200-299喽*
>
> ***情况2**（百位小于2），如12113
> 要想百位出现2，由于当前位是1，那么最终的次数同样依赖于更高位，只不过会比上面的情况少最后一种
> 00200-00299 100个数
> 01200-01299 100个数
> ...
> 11200-11299 100个数
> 那么加起来就是（12）*10**len('13')
> 结论2：当前位小于2=（当前位的左边部分）*10**当前位的右半部分的长度，这里就是 12*10**len('13')*
>
> ***情况3**（百位2等于2），如12213
> 这种情况稍微复杂那么一丢丢，百位出现2的情况不仅依赖于左半边，还依赖于右半边，不过想通了也就不难了
> 我们可以将这个数分成两部分：
> 首先我们取前三位不大于121的所有情况，就是上面的结论2
> 00200-00299 100个数
> 01200-01299 100个数
> ...
> 11200-11299 100个数，还是12*100个数，（12咋来的？从0到11共12个数哇，100咋来的？从0到99共100个数哇）
> 其次我们取前三位是122的情况，
> 12200-12213 这一共是14个数，总的加起来就是百位是2的所有情况了
> 结论三：当前位等于2=（当前位的左边部分）*10**当前位的右半部分的长度+当前位的右半部分+1 ，这里就是 12*10**len('13')+13+1 13+1就是从0到13共几个数

最后整理成代码逻辑就是：

    sum=0
    依次遍历字符串（正好从高位到低位遍历一遍）：
        case(当前位大于带查找数)：
            sum +=（当前位的左边部分+1）*10**当前位的右半部分的长度
        case(当前位小于带查找数):
            sum +=（当前位的左边部分）*10**当前位的右半部分的长度
        case(当前位等于带查找数)：
            sum +=（当前位的左边部分）*10**当前位的右半部分的长度+当前位的右半部分+1 

## Pow(x, n)

题目：https://leetcode-cn.com/problems/powx-n/

>
>
>实现 pow(x, n) ，即计算 x 的 n 次幂函数。
>
>**示例 1:**
>
>```
>输入: 2.00000, 10
>输出: 1024.00000
>```
>
>**示例 2:**
>
>```
>输入: 2.10000, 3
>输出: 9.26100
>```
>
>**示例 3:**
>
>```
>输入: 2.00000, -2
>输出: 0.25000
>```
>
>解释: 2-2 = 1/22 = 1/4 = 0.25
>
>说明:
>
>-100.0 < x < 100.0
>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

solution:

```C++
    class Solution {
    public:
        double myPow(double x, int n) {
            if(n == 0) {
                return 1.0;
            } 
            if(n < 0) {
                return 1 / x * myPow(1 / x, - (n + 1));
            } 
            return n & 1 == 1 ? x * myPow(x * x, n / 2) : myPow(x * x, n / 2);
        }
    };
```

分析：

* 此方法利用的是**快速幂 + 递归**

* 当我们要计算 $x^n$时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$其中 $\lfloor a \rfloor$ 表示对 $a$ 进行下取整；

* 根据递归计算的结果，如果 $n$为偶数，那么 $x^n = y^2$;如果 $n$为奇数，那么$ x^n = y^2 * x$；

* 递归的边界为 $n = 0$，任意数的0次方均为 1。

* 由于每次递归都会使得指数减少一半，因此递归的层数为$ O(\log n)$，算法可以在很快的时间内得到结果

* 时间复杂度：$O(logn)$，即为递归的层数。

  空间复杂度：$O(\log n)$，即为递归的层数。这是由于递归的函数调用会使用栈空间。

* 优化：**快速幂 + 迭代**可以时间复杂度不变，空间复杂度为$O(1)$

# 其他

## 素数

题目：如何高效寻找素数

[https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0.md](https://github.com/labuladong/fucking-algorithm/blob/master/高频面试系列/打印素数.md)

solution：

```c++
int countPrimes(int n) {
    boolean[] isPrim = new boolean[n];
    Arrays.fill(isPrim, true);
    for (int i = 2; i * i < n; i++) //优化
        if (isPrim[i]) 
            for (int j = i * i; j < n; j += i) //优化2
                isPrim[j] = false;
    
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrim[i]) count++;
    
    return count;
}
```

注：

* 判断一个数是否是素数的 `isPrime` 函数，由于因子的对称性，其中的 for 循环只需要遍历 `[2,sqrt(n)]` 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 `sqrt(n)`

* 比如 `n = 25`，`i = 4` 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 `i = 2` 和 `i = 3` 的 2 × 4 和 3 × 4 标记了。

## 剪绳子

题目：

>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
>
>示例 1：
>
>输入: 2
>输出: 1
>解释: 2 = 1 + 1, 1 × 1 = 1
>示例 2:
>
>输入: 10
>输出: 36
>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

solution:

```C++
class Solution {
public:
    int cuttingRope(int n) {
        if( n<= 3)
            return 1 * (n - 1);
        int res = 1;
        if(n % 3 == 1) {
            res = 4;
            n -= 4;
        } else if(n % 3 == 2) {
            res = 2;
            n -= 2;
        }
        while(n){
            res *= 3;
            n -= 3;
        }
        return res; 
    }
};
```

* 最优： 33 。把绳子尽可能切为多个长度为 33 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,2 三种情况。

  次优： 22 。若最后一段绳子长度为 22 ；则保留，不再拆为 1+11+1 。

  最差： 11 。若最后一段绳子长度为 11 ；则应把一份 3 + 13+1 替换为 2 + 22+2，因为 2 \times 2 > 3 \times 12×2>3×1。



## 有效的括号

题目：

>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
>有效字符串需满足：
>
>左括号必须用相同类型的右括号闭合。
>左括号必须以正确的顺序闭合。
>注意空字符串可被认为是有效字符串。
>
>示例 1:
>
>输入: "()"
>输出: true
>示例 2:
>
>输入: "()[]{}"
>输出: true
>示例 3:
>
>输入: "(]"
>输出: false
>示例 4:
>
>输入: "([)]"
>输出: false
>示例 5:
>
>输入: "{[]}"
>输出: true

solution:

```C++
class Solution {
public:
        bool check(char c1, char c2) {
            switch(c1) {
                case '}':
                    return c2 == '{';
                case ']':
                    return c2 == '[';
                case ')':
                    return c2 == '(';
                default:
                    return false;
            }
        }
        bool isValid(string s) {
            stack<char> st;
            int n = s.size();
            for(int i = 0; i < n; i++) {
                char c1 = s[i];
                if(c1 == '(' || c1 == '{' || c1 == '[') {
                    st.push(c1);
                } else {
                    if(st.empty()) return false;
                    if(!check(c1, st.top())) return false;
                    st.pop();
                }
            }
            return st.empty();
        }
};
```

分析：

* 栈调用

* 时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1)的推入和弹出操作。
* 空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((

## 机器人能否返回原

>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。
>
>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。
>
>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。
>
> 
>
>示例 1:
>
>输入: "UD"
>输出: true
>解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。
>示例 2:
>
>输入: "LL"
>输出: false
>解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。

solution:

```C++
class Solution {
public:
    bool judgeCircle(string moves) {
        int hDirection = 0; //horizontal direction
        int vDirection = 0; //vertical direction
        for (int i = 0; i < moves.length(); i++) {
            switch (moves[i]) {
                case 'U':
                    vDirection++;
                    break;
                case 'D':
                    vDirection--;
                    break;
                case 'L':
                    hDirection--;
                    break;
                case 'R':
                    hDirection++;
                default:
                    break;
            }
        }
        return vDirection == 0 && hDirection == 0 ? true : false;
    }
};
```

## 矩阵置零

题目：

>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。
>
>示例 1:
>
>输入: 
>[
>  [1,1,1],
>  [1,0,1],
>  [1,1,1]
>]
>输出: 
>[
>  [1,0,1],
>  [0,0,0],
>  [1,0,1]
>]
>示例 2:
>
>输入: 
>[
>  [0,1,2,0],
>  [3,4,5,2],
>  [1,3,1,5]
>]
>输出: 
>[
>  [0,0,0,0],
>  [0,4,5,0],
>  [0,3,1,0]
>]
>进阶:
>
>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
>你能想出一个常数空间的解决方案吗？
>
>

solution:

```C++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        bool row_flag = false;
        bool col_flag = false;
        
        for(int i = 0; i < row; i++) {
            if(matrix[i][0]== 0) {
                row_flag = true;
                break;
            }
        }
        for(int j = 0; j < col; j++) {
            if(matrix[0][j]== 0) {
                col_flag = true;
                break;
            }
        }

        for(int i = 1; i < row; i++) {
            for(int j = 1; j < col; j++) {
                if(matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        for(int i = 1; i < row; i++) {
            if(matrix[i][0]== 0) {
                for(int j = 1; j < col; j++) {
                    matrix[i][j] = 0;
                }
            }
        } 
        for(int j = 1; j < col; j++) {
            if(matrix[0][j]== 0) {
                for(int i = 1; i < row; i++) {
                    matrix[i][j] = 0;
                }
            }
        }

        if(row_flag) {
            for(int i = 0; i < row; i++) {
                matrix[i][0] = 0;
            }
        }
        if(col_flag) {
            for(int j = 0; j < col; j++) {
                matrix[0][j] = 0;
            }
        }        
    }
};
```



## 用队列实现栈

题目：https://leetcode-cn.com/problems/implement-stack-using-queues/

>
>
>使用队列实现栈的下列操作：
>
>push(x) -- 元素 x 入栈
>pop() -- 移除栈顶元素
>top() -- 获取栈顶元素
>empty() -- 返回栈是否为空
>注意:
>
>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

solution:

```c++
class MyStack {
private:
    queue<int> q;
    int size;
public:
    /** Initialize your data structure here. */
    MyStack() {
        size = 0;
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
        size++;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        for(int i=1; i< size; i++){
            q.push(q.front());
            q.pop();
        }
        int res = q.front();
        q.pop();
        size--;
        return res;
    }
    
    /** Get the top element. */
    int top() {
        return q.back();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};
```

## 用栈实现队列

题目：https://leetcode-cn.com/problems/implement-queue-using-stacks/

>使用栈实现队列的下列操作：
>
>push(x) -- 将一个元素放入队列的尾部。
>pop() -- 从队列首部移除元素。
>peek() -- 返回队列首部的元素。
>empty() -- 返回队列是否为空。
>示例:
>
>MyQueue queue = new MyQueue();
>
>queue.push(1);
>queue.push(2);  
>queue.peek();  // 返回 1
>queue.pop();   // 返回 1
>queue.empty(); // 返回 false
>说明:
>
>你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

solution：

```c++
class MyQueue {
private:
    stack<int> s1, s2;
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int ret = s2.top();
        s2.pop();
        return ret;
    }
    
    /** Get the front element. */
    int peek() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int ret = s2.top();
        return ret;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

## LRU

(注意先更新map的node的value值，然后移动该node到List头，再用map指定该node)

```C++
struct CacheNode{
    int key;
    int value;
    CacheNode(int k, int v):key(k), value(v){}
};

class LRUCache {
private:
    list<CacheNode> cacheList;
    unordered_map<int, list<CacheNode>::iterator> cacheMap;
    int size;
public:
    LRUCache(int capacity) {
        size = capacity;
        cacheMap.clear();
    }
    
    int get(int key) {
        if(cacheMap.find(key) == cacheMap.end()) {
            return -1;
        } else {
            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);//move的作用，move后cacheMap[key]为空需要指定
            cacheMap[key] = cacheList.begin();
            return cacheMap[key]->value; //别写成了return cacheMap[key]
        }
    }
    
    void put(int key, int value) {
        if(cacheMap.find(key) == cacheMap.end()) {
            if(cacheList.size() == size) {
                cacheMap.erase(cacheList.back().key);
                cacheList.pop_back();
            } 
            cacheList.push_front(CacheNode(key, value));
            cacheMap[key] = cacheList.begin();
        } else {
            cacheMap[key]->value = value;
            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);
            cacheMap[key] = cacheList.begin();
        }
    }
};
```

## LFU

```C++
struct Node {
    int key, val, freq;
    Node(int _key,int _val,int _freq): key(_key), val(_val), freq(_freq){}
};
class LFUCache {
    int minfreq, capacity;
    unordered_map<int, list<Node>::iterator> key_table;
    unordered_map<int, list<Node>> freq_table;
public:
    LFUCache(int _capacity) {
        minfreq = 0;
        capacity = _capacity;
        key_table.clear();
        freq_table.clear();
    }
    
    int get(int key) {
        if (capacity == 0) return -1;
        auto it = key_table.find(key);
        if (it == key_table.end()) return -1;
        list<Node>::iterator node = it -> second;
        int val = node -> val, freq = node -> freq;
        freq_table[freq].erase(node);
        // 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq
        if (freq_table[freq].size() == 0) {
            freq_table.erase(freq);
            if (minfreq == freq) minfreq += 1;
        }
        // 插入到 freq + 1 中
        freq_table[freq + 1].push_front(Node(key, val, freq + 1));
        key_table[key] = freq_table[freq + 1].begin();
        return val;
    }
    
    void put(int key, int value) {
        if (capacity == 0) return;
        auto it = key_table.find(key);
        if (it == key_table.end()) {
            // 缓存已满，需要进行删除操作
            if (key_table.size() == capacity) {
                // 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点
                auto it2 = freq_table[minfreq].back();
                key_table.erase(it2.key);
                freq_table[minfreq].pop_back();
                if (freq_table[minfreq].size() == 0) {
                    freq_table.erase(minfreq);
                }
            } 
            freq_table[1].push_front(Node(key, value, 1));
            key_table[key] = freq_table[1].begin();
            minfreq = 1;
        } else {
            // 与 get 操作基本一致，除了需要更新缓存的值
            list<Node>::iterator node = it -> second;
            int freq = node -> freq;
            freq_table[freq].erase(node);
            if (freq_table[freq].size() == 0) {
                freq_table.erase(freq);
                if (minfreq == freq) minfreq += 1;
            }
            freq_table[freq + 1].push_front(Node(key, value, freq + 1));
            key_table[key] = freq_table[freq + 1].begin();
        }
    }
};
```



# 经验总结

## DFS

1. 先判断root == NULL
2. 然后判断叶子节点
3. 再判断逻辑（条件比较，更新期望值）
4. 返回 所求值

## 回溯法

* 利用一个堆栈或者字符串等存储器
* 先入存储器，遍历（下一个字符或者其左右节点），然后再从存储器pop出来

## 双向BFS

广度优先搜索遵循从初始结点开始一层层扩展直到找到目标结点的搜索规则，它只能较好地解决状态不是太多的情况，承受力很有限。如果扩展结点较多，而目标结点又处在较深层，采用前文叙述的广度搜索解题，搜索量巨大是可想而知的，往往就会出现内存空间不够用的情况。双向搜索和A算法对广度优先的搜索方式进行了改良或改造，加入了一定的“智能因素”，使搜索能尽快接近目标结点，减少了在空间和时间上的复杂度。

## C++语法

* int 转字符串 to_string, 字符串转int stoi(）

* unordered_map hash表， 其find()返回迭代，count返回int

  ```C++
  vector (向量)
      vector<int> vec;
      empty(), push_back(), pop_back(),begin(), end(), front(), back(), size(), insert() vec[i]
      vector<char>::iterator iter1; iter1 = v1.end()-1; //注意v1.end()指向的是最后一个元素的下一个位置，所以访问最后一个元素
                          //的正确操作为：v1.end() - 1;
      res.insert(res.begin() + cur, newInterval);
  
  stack 
       stack<int> s
       top(), empty(), size(), pop(), push()
  
  queue  
      queue<int> q1
      front(), back(), empty(), size(), pop(), push(), 
  deque  
      queue<int> q1
    pop_front(), pop_back(), push_back(), push_front()
  list （Lists将元素按顺序储存在链表中. 与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢）
      front() 返回第一个元素                 back() 返回最后一个元素 
      begin() 返回指向第一个元素的迭代器          end() 返回末尾的迭代器
      pop_back() 删除最后一个元素             pop_front() 删除第一个元素 
      push_back() 在list的末尾添加一个元素    push_front() 在list的头部添加一个元素
      reverse() 把list的元素倒转                sort() 给list排序
      splice() 合并两个list                 size() 返回list中的元素个数 
  
  set
      set<int> s;
      begin()返回set容器的第一个元素            end()返回set容器的最后一个元素
      clear()删除set容器中的所有的元素        empty()判断set容器是否为空
      size()返回当前set容器中的元素个数        max_size()返回set容器可能包含的元素最大个数
      rend()返回的值和rbegin()相同            rbegin返回的值和end()相同
  
  unordered_map
      begin        返回指向容器起始位置的迭代器
      end            返回指向容器末尾位置的迭代器
      size        返回有效元素个数
      max_size    返回 unordered_map 支持的最大元素个数
      empty        判断是否为空
      insert        插入元素
      find        通过给定主键查找元素
      count    
      遍历 unordered_map.begin() .end()
  priority_queue<int> pq;大根堆
  		pq.push
    priority_queue<ListNode*, vector<ListNode*>, cmp> q;
    struct cmp {
        bool operator () (ListNode *a, ListNode *b) {
            return a->val > b->val;
        }
    };
  unordered_set
      t.insert();
      t.erase();
      t.find();
      t.count();
  string
      str.size()  "" 返回0
      str.empty() "" 返回1
    
  vector和list区别
  1.vector数据结构
  vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
  因此能高效的进行随机存取，时间复杂度为o(1);
  但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
  另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。
  
  2.list数据结构
  list是由双向链表实现的，因此内存空间是不连续的。
  只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
  但由于链表的特点，能高效地进行插入和删除。
  ```

* 字符串去除最后一个字符string path = "xxxx";path.pop_back();

* 字符串去除第一个字符s.substr(1)；

* string s = 'a' + 1; 报错，但是可以string s; s = 'a' + 1;

* 注释标准

  ```C++
  /** 
   * @brief 函数简要说明-测试函数
   * @param index    参数1
   * @param t        参数2 @see CTest
   *
   * @return 返回说明
   *     -<em>false</em> fail
   *     -<em>true</em> succeed
   */
  bool Test(int index, const CTest& t);
  ```

  

## 动态规划

* 对于链条问题，上下节点有规律的制约则可以考虑用动规
* 从简单的举例开始推导普通情况得到方程

## 消除后效性

* 在设计状态的时候，**在后面加一维，消除后效性**；

## 取模

* 不要用%2 判断奇偶，可以用& 1

## 时间复杂度 空间复杂度

* 二分法的时间复杂度是O(logN)
* 单递归能实现类似二分法的则时间复杂度是O(logN)，否则为O(N)
* 递归的空间复杂度为O(N)

## 字典树

* 字典树，又称为单词查找树，Tire数，是一种树形结构，它是一种哈希树的变种
* 基本性质
  * 根节点不包含字符，除根节点外的每一个子节点都包含一个字符
  * 根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串
  * 每个节点的所有子节点包含的字符都不相同

```C++
class TrieNode // 字典树节点
{
  private int num;// 有多少单词通过这个节点,即由根至该节点组成的字符串模式出现的次数
  private TrieNode[] son;// 所有的儿子节点
  private boolean isEnd;// 是不是最后一个节点
  private char val;// 节点的值

  TrieNode()
  {
    num = 1;
    son = new TrieNode[SIZE];
    isEnd = false;
  }
}   
```

## 并查集

* 又叫联合查找

* data[i] = i

  题目：

  >给定一棵树,找到一个点，使得与其他节点距离总和最小值

  ```C++
  构造最小生成树的算法主要有：克鲁斯卡尔（Kruskal）算法和普利姆（Prim）算法
  #include <iostream>
  #include<vector>
  #include<algorithm>
  using namespace std;
  /*边的定义*/
  struct edge
  {
      int u, v;                                //边的两个端点编号
      int cost;                                //边权
      edge(int x,int y, int c):u(x),v(y),cost(c){}
  };
  
  /*边的比较函数*/
  bool cmp(edge a, edge b)
  {
      return a.cost < b.cost;
  }
  
  /*并查集查询函数，返回x所在集合的根结点,并查集可以通过查询两个结点所在集合的根结点是否相同来判断它们是否在同一个集合中*/
  int findFather(vector<int> father, int x) {
      int a = x;
      while (x != father[x])
          x = father[x];
      //路径压缩
      while (a != father[a]) {
          father[a] = x;
          a = father[a];
      }
      return x;
  }
  
  /*Kruskal算法求无向图的最小生成树*/
  int Kruskal(int n, int m, vector<edge>& E) {
      /*
         param
         n:                         图的顶点个数
         m:                         图中边的个数
         E:                         边的集合
         */
      vector<int> father(n);                                 //并查集数组
      int ans = 0;                                           //所求边权之和
      int NumEdge = 0;                                       //记录最小生成树边数
      for (int i = 0; i < n; i++)                            //初始化并查集
          father[i] = i;
      sort(E.begin(), E.end(), cmp);                         //所有边按边权从小到大排序
      for (int i = 0; i < m; ++i)                            //枚举所有边
      {
          int faU = findFather(father, E[i].u);           //查询端点u所在集合的根结点
          int faV = findFather(father, E[i].v);           //查询端点v所在集合的根结点
          if (faU != faV) {                               //如果不在一个集合中
              father[faU] = faV;                       //合并集合（相当于把测试边加入到最小生成树）
              ans += E[i].cost;
              NumEdge++;                               //当前生成树边数加1
              if (NumEdge == n - 1)                    //边数等于顶点数减1，算法结束
                  break;
          }
      }
      if (NumEdge != n - 1)                                  //无法连通时返回-1
          return -1;
      else
          return ans;                                     //返回最小生成树边权之和
  }
  
  int main()
  {
      vector<edge> E = { edge(0,1,4),edge(1,2,1),edge(2,3,6),edge(3,4,5),edge(0,4,1), edge(0,5,2),edge(1,5,3),edge(2,5,5),edge(3,5,4),edge(4,5,3) };
      int n = 6;
      int m = 10;
      int res = Kruskal(n, m, E);
      cout << res << endl;
  }
  ```

  

# 附录

https://github.com/labuladong/fucking-algorithm