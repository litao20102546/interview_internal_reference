# 字符串

## 最长公共子序列

题目：https://leetcode-cn.com/problems/longest-common-subsequence/

类似题目：[公共祖先](# 公共祖先，最低共同父节点 )

>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
>
>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
>
>若这两个字符串没有公共子序列，则返回 0。
>
>**示例 1:**
>
>```
>输入：text1 = "abcde", text2 = "ace" 
>输出：3  
>解释：最长公共子序列是 "ace"，它的长度为 3。
>```
>
>**示例 2:**
>
>```
>输入：text1 = "abc", text2 = "abc"
>输出：3
>解释：最长公共子序列是 "abc"，它的长度为 3。
>```
>
>**示例 3:**
>
>```
>输入：text1 = "abc", text2 = "def"
>输出：0
>解释：两个字符串没有公共子序列，返回 0。
>```
>
>**提示:**
>
>1 <= text1.length <= 1000
>1 <= text2.length <= 1000
>输入的字符串只含有小写英文字符。

solution：

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        int table[m+1][n+1];//table[ i ][ j ]为字符串A的第一个字符到第 i 个字符串和字符串B的第一个字符串到第 j 个字符串的最长公共子序列
        for(int i=0; i<= m; i++){
            table[i][0] = 0;
        }
        for(int i=0; i<=n; i++) {
            table[0][i] = 0;
        }
        for(int i=1; i<=m; i++) {
            for(int j=1; j<=n; j++) {
                if(text1[i-1] == text2[j-1]) {
                    table[i][j] = table[i-1][j-1]+1;
                } else{
                    table[i][j] = max(table[i][j-1], table[i-1][j]);
                }
            }
        }
        return table[m][n];
    }
};
```

分析：

>   table\[i][j][为字符串A的第一个字符到第 i 个字符串和字符串B的第一个字符串到第 j 个字符串的最长公共子序列
>
>   当我们要求table\[i][j]，我们要先判断A[i]和B[j]是否相同，
>    如果相同他就是table\[i-1][j-1] + 1，相当于在两个字符串都去掉一个字符时的最长公共字串再加 1；
>    否则最长公共字串取table\[ i ][ j - 1 ] 和table\[ i - 1 ][ j ] 中大者。
>   
>   

## 最长公共子串

题目：(dp)子串是要求更严格的一种子序列，要求在母串中连续地出现。

> Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
>
> Input:
> A: "12321"
> B: "32147"
> Output: 3
> Explanation:
> The repeated subarray with maximum length is [3, 2, 1].

solution:

```c++
    class LongestSubstring {
    public:
        int findLongest(string A, int n, string B, int m) {
            int dp[1000][1000] = {0};//必须清零
            int max_len = 0;
            for(int i = 0;i < n;i++) {
                for(int j = 0;j < m;j++) {
                    if(A[i] == B[j]) {
                        if(i >0 && j>0) {
                            dp[i][j] = dp[i-1][j-1] +1;
                        }
                        else {
                            dp[i][j] = 1; // i= j= 0  的时候，不能使用上面那个公式，所以要单独写
                        }
                    }
                    if(max_len < dp[i][j]) {
                        max_len = dp[i][j];
                    }
                }
            }
            return max_len ;
        }
    };
```

分析：

 dp\[i][j]表示取到A[i]和取到B[j]时的最大连续子串长度,如果A[i]等于B[j]，则dp\[i-1][j-1]等于取到A1[i-1]和取到B[j-1]时的最大连续子串长度加1，即dp\[i][j]=dp\[i-1][j-1]+1。

因为最大长度不一定用到最后的字符，所以需要有个变量max_len记录最长的公共子字符串。

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/动态规划.png" alt="动态规划" style="zoom:30%;" />

## 括号有效性

题目：https://leetcode-cn.com/problems/valid-parentheses/

>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
>
>有效字符串需满足：
>
>左括号必须用相同类型的右括号闭合。
>左括号必须以正确的顺序闭合。
>注意空字符串可被认为是有效字符串。
>
>**示例 1:**
>
>```
>输入: "()"
>输出: true
>
>```
>
>**示例 2:**
>
>```
>输入: "()[]{}"
>输出: true
>```
>
>**示例 3:**
>
>```
>输入: "(]"
>输出: false
>```
>
>**示例 4:**
>
>```
>输入: "([)]"
>输出: false
>```
>
>**示例 5:**
>
>```
>输入: "{[]}"
>输出: true
>```

solution:

```c++
    class Solution {
    public:
        bool check(char c1, char c2) {
            switch(c1) {
                case '}':
                    return c2 == '{';
                case ']':
                    return c2 == '[';
                case ')':
                    return c2 == '(';
                default:
                    return false;
            }
        }
        bool isValid(string s) {
            stack<char> st;
            int n = s.size();
            for(int i = 0; i < n; i++) {
                char c1 = s[i];
                if(c1 == '(' || c1 == '{' || c1 == '[') {
                    st.push(c1);
                } else {
                    if(st.empty()) return false;
                    if(!check(c1, st.top())) return false;
                    st.pop();
                }
            }
            return st.empty();
        }
    };
```

分析：利用栈的原理先进后出

## 无重复字符的最长子串

题目：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

相似题目：[至多包含两个不同字符的最长子串](# 至多包含两个不同字符的最长子串)

>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
>
>**示例 1:**
>
>```
>输入: "abcabcbb"
>输出: 3 
>解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
>```
>
>**示例 2:**
>
>```
>输入: "bbbbb"
>输出: 1
>解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
>```
>
>**示例 3:**
>
>```
>输入: "pwwkew"
>输出: 3
>解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
>```

solution:

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int res = 0, left = 0, right = 0, n = s.size();
        unordered_set<char> t;
        while (right < n) {
            if (!t.count(s[right])) {
                t.insert(s[right++]);
                res = max(res, (int)t.size());
            }  else {
                t.erase(s[left++]);
            }
        }
        return res;
    }
};
```

分析：

* 此方法是**滑动窗口**
* 用数据结构来判断 **是否有重复的字符**（即 `C++` 中的 `std::unordered_set`，`Java` 中的 `HashSet`，`Python` 中的 `set`, `JavaScript` 中的 `Set`）
* 使用两个指针表示字符串中的某个子串（的左右边界）。其中左指针代表着上文中「枚举子串的起始位置」

## 至多包含两个不同字符的最长子串

题目：https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters

相似题目：[无重复字符的最长子串](# 无重复字符的最长子串)

>- 给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。
>- 示例 1:
>  输入: “eceba”
>  输出: 3
>  解释: t 是 “ece”，长度为3。
>- 示例 2:
>  输入: “ccaabbb”
>  输出: 5
>  解释: t 是 “aabbb”，长度为5。

solution:

```c++
// 滑动窗口
// 时间复杂度：O(n) 空间复杂度：O(n)
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        unordered_map<char, int> m;
        int cnt = 0;                // 不同字符个数
        int left = 0, right = 0;    // right指向的是窗口外的下一个字符
        int maxLen = 0;
        while(right < s.size()){
            if(m[s[right]] == 0)
                cnt ++;             // 出现新字符
            m[s[right++]]++;        // 计数+1并右移
            while(cnt > 2){         // 当窗口元素大于2，窗口缩小
                m[s[left]]--;       // 计数-1
                if(m[s[left++]] == 0){
                    cnt --;         // 字符计数减为0
                }
            }
            maxLen = max(maxLen, right - left); // 满足条件的窗口长度
        }
        return maxLen;
    }
};
```

分析：

* 利用cnt来维护不同字符个数，使窗口内不同字符个数不超过2
* 如果超过2，此时temp = s[left], 则left指针往后移，一直到最后一个temp被移出去。
* 如果是求至多包含 K 个不同字符的最长子串，则将`cnt > 2`换为`cnt > k`即可，如下：

```c++
/*
 * 滑动窗口+哈希表
 * 时间复杂度O(n) 空间复杂度O(k)
 */
class Solution {
public:
    int lengthOfLongestSubstringKDistinct(string s, int k) {
        if(s.size() == 0 || k <= 0)
            return 0;
        unordered_map<char, int > m;
        int l = 0, r = 0;   // 滑动窗口左右指针
        int maxLen = 1;     // 最大长度
        int count = 0;
        while(r < s.size()){
            if (m[s[r]] == 0)
                count ++;
            m[s[r]] += 1;
            r++;
            // 左指针移动减小
            while (count > k){
                if(m[s[l]] == 1)
                    count--;
                m[s[l]] -= 1;
                l++;
            }
            maxLen = max(maxLen, r - l);
        }
        return maxLen;
    }
};
```

## K 个不同整数的子数组

题目：https://leetcode-cn.com/problems/subarrays-with-k-different-integers/

>给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。
>
>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）
>
>返回 A 中好子数组的数目。
>
>
>
>**示例 1：**
>
>```
>输入：A = [1,2,1,2,3], K = 2
>输出：7
>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
>```
>
>**示例 2：**
>
>```
>输入：A = [1,2,1,3,4], K = 3
>输出：3
>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
>```
>
>
>提示：
>
>1 <= A.length <= 20000
>1 <= A[i] <= A.length
>1 <= K <= A.length

```C++
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int N = A.size();
        vector<int> counts(N + 1, 0);
        int l = 0;
        int c = 0;
        int res = 0;
        for (int i = 0; i < N; ++i) {
            if (counts[A[i]]++ == 0) ++c;
            while (c > K) {
                if (--counts[A[l]] == 0) --c;
                ++l;
            }
            int t = l;
            if (c == K) {
                // count res
                while (c == K) {
                    if (--counts[A[t]] == 0) --c;
                    ++t;
                    ++res;
                }
                // recover counts
                for (int j = l; j < t; ++j) {
                    if (counts[A[j]]++ == 0) ++c;
                }
            }
        }
        return res;
    }
};

```

**解题思路**

我们定义`[i,j)`这个区间内的元素表示**最少的**构成`K`个不同整数的子区间，而`[i,k)`表示**最少的**构成`K+1`个不同整数的子区间，那么此时以`A[i]`为起始的`k`个不同整数组成的子数组个数有`k-j+1`个。

1，双指针，`l`指向左端，`i`作为右端不断往右滑动
2，一旦可以凑出正好`K`个整数，则尝试滑动`l`找到当前情况下的所有可能，并记得复原状态

# 数组

## 删除排序数组中的重复项

题目：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

相似题目：[删除排序链表中的重复元素](# 删除排序链表中的重复元素)

>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
>
>**示例 1:**
>
>```
>给定数组 nums = [1,1,2], 
>
>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
>
>你不需要考虑数组中超出新长度后面的元素。
>```
>
>**示例 2:**
>
>```
>给定 nums = [0,0,1,1,1,2,2,3,3,4],
>
>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
>```
>
>你不需要考虑数组中超出新长度后面的元素。

solution：

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        int slow = 0, fast = 1;
        while (fast < n) {
            if (nums[fast] != nums[slow]) {
                slow++;
                // 维护 nums[0..slow] 无重复
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 长度为索引 + 1
        return slow + 1; 
    }
};
```

分析：让慢指针 `slow` 走左后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，**`nums[0..slow]` 就是不重复元素，之后的所有元素都是重复元素**。

我们知道对于数组来说，在尾部插入、删除元素是比较高效的，时间复杂度是 O(1)，但是如果在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为 O(N)，效率较低。

显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。而且题目要求我们原地修改，也就是说不能用辅助数组，空间复杂度得是 O(1)。

## 最小的K个数

题目：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/

>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
>
>**示例 1**：
>
>```
>输入：arr = [3,2,1], k = 2
>输出：[1,2] 或者 [2,1]
>```
>
>**示例 2：**
>
>```
>输入：arr = [0,1,2,1], k = 1
>输出：[0]
>```
>
>
>限制：
>
>0 <= k <= arr.length <= 10000
>0 <= arr[i] <= 10000

solution

1. 排序

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int> vec(k, 0);
        sort(arr.begin(), arr.end());
        for (int i = 0; i < k; ++i) vec[i] = arr[i];
        return vec;
    }
};
```

分析：

复杂度分析

时间复杂度：O(nlog n)，其中 n是数组 arr 的长度。算法的时间复杂度即排序的时间复杂度。

空间复杂度：O(nlog n)，排序所需额外的空间复杂度为 O(nlog n)。

2. 堆

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        vector<int>vec(k, 0);
        if (k == 0) return vec; // 排除 0 的情况
        priority_queue<int>Q;
        for (int i = 0; i < k; ++i) Q.push(arr[i]);
        for (int i = k; i < (int)arr.size(); ++i) {
            if (Q.top() > arr[i]) {
                Q.pop();
                Q.push(arr[i]);
            }
        }
        for (int i = 0; i < k; ++i) {
            vec[i] = Q.top();
            Q.pop();
        }
        return vec;
    }
};
```

分析：

* 我们用一个大根堆实时维护数组的前 kk 小值。首先将前 kk 个数插入大根堆中，随后从第 k+1k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的对为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 kk 小值。
* 时间复杂度：`O(nlog(k))`，其中 n是数组 arr 的长度。由于大根堆实时维护前 k 小值，所以插入删除都是 `O(log(k))` 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要`O(nlog(k))` 的时间复杂度。
* 空间复杂度：`O(k)`，因为大根堆里最多 k 个数。

3. 快排思想

```c++
class Solution {
public:
    int partition(vector<int>& data, int low, int high)
    {
        int temp = data[low];
        while(low < high){
            while((low < high) && (data[high] >= temp)){
                high--;
            }
            data[low] = data[high];
            while((low < high) && (data[low] <= temp)){
                low++;
            }
            data[high] = data[low];

        }
        data[low] = temp;
        return low;
    }
    void randomized_selected(vector<int>& arr, int l, int r, int k) {
        if (l >= r) return;
        int pos = partition(arr, l, r);
        int num = pos - l + 1; // l到pos之间小于等于arr[pos]的个数
        if (k == num) return;
        else if (k < num) randomized_selected(arr, l, pos - 1, k);
        else randomized_selected(arr, pos + 1, r, k - num);  
    }
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        randomized_selected(arr, 0, (int)arr.size() - 1, k);
        vector<int>vec;
        for (int i = 0; i < k; ++i) vec.push_back(arr[i]);
        return vec;

    }
};
```

* >
  >
  >我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。
  >
  >我们定义函数 randomized_selected(arr, l, r, k) 表示划分数组 arr 的 [l,r] 部分，使前 k 小的数在数组的左侧，在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 pos - l + 1 小的数，那么一共会有三种情况：
  >
  >​	1) 如果 pos - l + 1 == k，表示 pivot 就是第 kk 小的数，直接返回即可；
  >
  >​	2) 如果 pos - l + 1 < k，表示第 k 小的数在 pivot 的右侧，因此递归调用 randomized_selected(arr, pos + 1, r, k - (pos - l + 1))；
  >
  >​	3) 如果 pos - l + 1 > k，表示第 k小的数在 pivot 的左侧，递归调用 randomized_selected(arr, l, pos - 1, k)。
  >
  >函数递归入口为 randomized_selected(arr, 0, arr.length - 1, k)。在函数返回后，将前 k 个数放入答案数组返回即可。
  >

* 时间复杂度：期望为 `O(n)` ，由于证明过程很繁琐，所以不再这里展开讲。具体证明可以参考《算法导论》第 9 章第 2 小节。最坏情况下的时间复杂度为 `O(n^2)`。情况最差时，每次的划分点都是最大值或最小值，一共需要划分 `n - 1`次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 `O(n^2)`。

* 空间复杂度：期望为 `O(log n)`，递归调用的期望深度为 `O(log n)`，每层需要的空间为` O(1)`，只有常数个变量。最坏情况下的空间复杂度为 `O(n)`。最坏情况下需要划分 n 次，即 randomized_selected 函数递归调用最深 n - 1 层，而每层由于需要 `O(1)` 的空间，所以一共需要` O(n)`的空间复杂度。

## 第K个只包含素因子的数

题目：https://leetcode-cn.com/problems/get-kth-magic-number-lcci/

类似题目：https://leetcode-cn.com/problems/chou-shu-lcof/

https://leetcode-cn.com/problems/ugly-number/submissions/

https://leetcode-cn.com/problems/ugly-number-ii/

https://leetcode-cn.com/problems/super-ugly-number/

>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。
>
>示例 1:
>
>输入: k = 5
>
>

solution：

```c++
class Solution {
public:
    int Min(int i, int j, int k) {
        int m = i > j ? j : i;
        return m > k ? k : m;
    }
    int getKthMagicNumber(int k) {
        int min = 0;
        int uglyNums[k];
        int m3=0, m5=0, m7=0;
        int next = 1;
        uglyNums[0] = 1;
        while(next < k) {
            min = Min(uglyNums[m3]*3, uglyNums[m5]*5, uglyNums[m7]*7);
            uglyNums[next++] = min;
            if(min == uglyNums[m3]*3)
                m3++;
            if(min == uglyNums[m5]*5)
                m5++;
            if(min == uglyNums[m7]*7)
                m7++;
        }
        return uglyNums[k - 1];         
    }
};
```

分析：

* 这个和找出第n个丑数题目类似，维护三个指针，分别是乘以3，乘以5，乘以7; 每次取这三个指针对应数的下一个中的最小者，如uglyNums[m3]的下一个数uglyNums[m3]*3， 然后给最小者加入uglyNums数组；
* 时间复杂度和空间复杂度都是`O(k)`

## 岛屿的数量

题目：

>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。
>
>##### 示例：
>
>> **示例 1:**
>>  **输入:**
>>  11110
>>  11010
>>  11000
>>  00000
>>  **输出:** 1
>>  **示例 2:**
>>  **输入:**
>>  11000
>>  11000
>>  00100
>>  00011
>>  **输出:** 3

solution:

```c++
    class Solution {
    public:
        void search(vector<vector<char>>& grid, int x, int y) {
            if(x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != '1') return;
            grid[x][y] = '0';
            search(grid, x - 1, y);
            search(grid, x + 1, y);
            search(grid, x, y - 1);
            search(grid, x, y + 1);
        }
        int numIslands(vector<vector<char>>& grid) {
            int count = 0;
            if(grid.empty()) return count;
            int rows = grid.size();
            int columns = grid[0].size();
            for(int i = 0; i < rows; i++) {
                for(int j = 0; j < columns; j++) {
                    if(grid[i][j] == '1') {
                        search(grid, i, j);
                        count++;
                    }
                    
                }
            }
            return count;
        }
    };
```

分析：

* 将已经遍历的节点值更改为0，查看四个方向的DFS

## Number of Islands II

题目：https://www.lintcode.com/problem/number-of-islands-ii/description

>给定 n, m, 分别代表一个二维矩阵的行数和列数, 并给定一个大小为 k 的二元数组A. 初始二维矩阵全0. 二元数组A内的k个元素代表k次操作, 设第i个元素为 `(A[i].x, A[i].y)`, 表示把二维矩阵中下标为A[i].x行A[i].y列的元素由海洋变为岛屿. 问在每次操作之后, 二维矩阵中岛屿的数量. 你需要返回一个大小为k的数组.
>
>### **Example**
>
>**样例 1:**
>
>```
>输入: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]]
>输出: [1,1,2,2]
>解释: 
>0.  00000
>    00000
>    00000
>    00000
>1.  00000
>    01000
>    00000
>    00000
>2.  01000
>    01000
>    00000
>    00000
>3.  01000
>    01000
>    00000
>    00010
>4.  01000
>    01000
>    00000
>    00011
>```
>
>**样例 2:**
>
>```
>输入: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]
>输出: [1,1,2,2]
>```

solution：

```c++
?
```

分析：

* 并查集

# 列表

## 是否有环 环形列表

题目：https://leetcode-cn.com/problems/linked-list-cycle/

>给定一个链表，判断链表中是否有环。
>
>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
>
>**示例 1：**
>
>```
>输入：head = [3,2,0,-4], pos = 1
>输出：true
>解释：链表中有一个环，其尾部连接到第二个节点。
>```
>
>**示例 2：**
>
>```
>输入：head = [1,2], pos = 0
>输出：true
>解释：链表中有一个环，其尾部连接到第一个节点。
>```
>
>**示例 3：**
>
>```
>输入：head = [1], pos = -1
>输出：false
>解释：链表中没有环。
>```

solution：

```c++
    class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(head == NULL || head->next == NULL) {
                return false;
            } else {
                ListNode *slow = head;
                ListNode *fast = head;
                while(fast != NULL && fast->next != NULL) {
                    slow = slow->next;
                    fast = fast->next->next;
                    if(slow == fast) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
```

## 求环入口

题目：https://leetcode-cn.com/problems/linked-list-cycle-ii/

>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
>
>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
>
>说明：不允许修改给定的链表。
>
> 
>
>**示例 1：**
>
>```
>输入：head = [3,2,0,-4], pos = 1
>输出：tail connects to node index 1
>解释：链表中有一个环，其尾部连接到第二个节点。
>```
>
>**示例 2：**
>
>```
>输入：head = [1,2], pos = 0
>输出：tail connects to node index 0
>解释：链表中有一个环，其尾部连接到第一个节点。
>```
>
>**示例 3：**
>
>```
>输入：head = [1], pos = -1
>输出：no cycle
>解释：链表中没有环。
>```

solution：

```c++
 /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=NULL&&fast->next!=NULL){
            slow=slow->next;
            fast=fast->next->next;
            if(slow==fast){
                slow=head;
                while(slow!=fast){
                    slow=slow->next;
                    fast=fast->next;
                }
                return fast;
            }
        }
        return NULL;
    }
};
```

## 删除排序链表中的重复元素

题目：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

相似题目：[删除排序数组中的重复项](# 删除排序数组中的重复项)

>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
>
>示例 1:
>
>```
>输入: 1->1->2
>输出: 1->2
>```
>
>示例 2:
>
>```
>输入: 1->1->2->3->3
>输出: 1->2->3
>```

solution：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) return NULL;
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast != NULL) {
            if (fast->val != slow->val) {
                // nums[slow] = nums[fast];
                slow->next = fast;
                // slow++;
                slow = slow->next;
            }
            // fast++
            fast = fast->next;
        }
        // 断开与后面重复元素的连接
        slow->next = NULL;
        return head;
    }
};
```

分析：



# 树

##  二叉树的镜像

题目：

>请完成一个函数，输入一个二叉树，该函数输出它的镜像。
>
>例如输入：
>
>         4
>       /   \
>      2     7
>     / \   / \
>    1   3 6   9
>    镜像输出：
>         4
>       /   \
>      7     2
>     / \   / \
>    9   6 3   1
> 
>
>示例 1：
>
>```
>输入：root = [4,2,7,1,3,6,9]
>输出：[4,7,2,9,6,3,1]
>```
>
>
>限制：
>
>0 <= 节点个数 <= 1000
>
>

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
            if(root == NULL) {
                return root;
            }
            TreeNode* temp = root->left;
            root->left = mirrorTree(root->right);
            root->right = mirrorTree(temp);
            return root;
    }
};
```

分析：

时间复杂度 O(N) ： 其中 N为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。
空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N)空间。

## 平衡二叉树

题目：https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/

>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
>
> 
>
>**示例 1:**
>
>给定二叉树 [3,9,20,null,null,15,7]
>
>    		3
>       / \
>      9  20
>        /  \
>       15   7
>
>
>返回 true 。
>
>
>
>示例 2:**
>
>给定二叉树 [1,2,2,3,3,null,null,4,4]
>
>           1
>          / \
>         2   2
>        / \
>       3   3
>      / \
>     4   4
>
>
>返回 false 。
>
> 
>
>限制：
>
>1 <= 树的结点个数 <= 10000

solution：

```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
class Solution {
public:
    bool isBalanceWithDepth(TreeNode* node, int& depth) {
      if(node == NULL){
        depth = 0;
        return true;
      }
      int left_depth, right_depth, diff_depth;
      bool left_is_balance = isBalanceWithDepth(node->left, left_depth);
      if(!left_is_balance) //为了剪枝
        return false;
      bool right_is_balance = isBalanceWithDepth(node->right, right_depth);
      if( left_is_balance && right_is_balance) {
        diff_depth = left_depth - right_depth;
        if(diff_depth >= -1 && diff_depth <= 1) {
          depth = left_depth > right_depth?left_depth+1:right_depth+1;
          return true;
        }
      }
      return false;
    }
    bool isBalanced(TreeNode* root) {
      int depth = 0;
      return isBalanceWithDepth(root, depth);
    }
};
```

**note:**优化->剪枝

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/树时间复杂度.png" alt="时间复杂度" style="zoom:50%;" />

​          * **空间复杂度 O(N)：**最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。

## 公共祖先，最低共同父节点

题目：https://leetcode-cn.com/problems/first-common-ancestor-lcci/

相似题目：[最长公共子序列](# 最长公共子序列)

>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。
>
>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]
>
>

    	  3  
    	 / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4
    示例 1:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    输入: 3
    解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
    示例 2:
    输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    输出: 5
    解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
    说明:
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。

solution：

```c++
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
    * };
    class Solution {
    public:
        bool GetNodePath(TreeNode* pRoot, TreeNode* pNode, list<TreeNode*> & path) {  
            if(pRoot == pNode) {     
                path.push_back(pRoot);  
                return true;  
            }  
            if(pRoot == NULL)
                return false;
            path.push_back(pRoot);  
            bool found = false;  
            found = GetNodePath(pRoot->left, pNode, path);  
            if(!found)  
                found = GetNodePath(pRoot->right, pNode, path);  
            if(!found)  
                path.pop_back();  
            return found;  
        }  

        TreeNode* GetLastCommonNode(const list<TreeNode*>& path1, const list<TreeNode*>& path2) 
        {
            TreeNode* pLast = NULL;  
            list<TreeNode*>::const_iterator iter1 = path1.begin();  
            list<TreeNode*>::const_iterator iter2 = path2.begin();  
            while(iter1 != path1.end() && iter2 != path2.end())  
            {  
                if(*iter1 == *iter2)  
                    pLast = *iter1;  
                else  
                    break;  
                iter1++;  
                iter2++;  
            }  
            return pLast; 
        }

        TreeNode* GetLastCommonParent(TreeNode* pRoot, TreeNode* pNode1, TreeNode* pNode2) {  
            if(pRoot == NULL || pNode1 == NULL || pNode2 == NULL)  
                return NULL;  
            list<TreeNode*> path1;  
            bool bResult1 = GetNodePath(pRoot, pNode1, path1);  
            list<TreeNode*> path2;  
            bool bResult2 = GetNodePath(pRoot, pNode2, path2);  
            if(!bResult1 || !bResult2)   
                return NULL;
            return GetLastCommonNode(path1, path2);   
        }
    };
```

**简单解法：**

```c++
    class Solution {
    public:
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            if (root == p || root == q || root == NULL) return root;
            TreeNode* left = lowestCommonAncestor(root -> left, p, q);
            TreeNode* right = lowestCommonAncestor(root -> right, p, q);
            if (left && right) return root;
            return left ? left : right;
        }
    };
```

**思路：**

本题为了简化题目，已经说明了所有的结点都是唯一的，p、q 不同且均存在于给定的二叉树中。因此我们有以下三种情况：

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/14.算法篇/公共节点.png" alt="三种情况" style="zoom:50%;" />

> 难点在于如何书写递归函数，不妨这样思考：
> 假设我们从跟结点开始，采用 DFS 向下遍历，如果当前结点到达叶子结点下的空结点时，返回空；如果当前结点为 p 或 q 时，返回当前结点；
> 这样，当我们令 left = self.lowestCommonAncestor(root.left, p, q) 时，如果在左子树中找到了 p 或 q，left 会等于 p 或 q，同理，right 也是一样；
> 然后我们进行判断：如果 left 为 right 都不为空，则为情况 1；如果 left 和 right 中只有一个不为空，说明这两个结点在子树中，则根节点到达子树再进行寻找。

**复杂度分析**

- 时间复杂度：O(n)。我们需要遍历每一个节点。
- 空间复杂度：O(n)，斜二叉树的高度为 n*n*。

## 前缀树（字典树）

### 实现前缀树

题目：https://leetcode-cn.com/problems/implement-trie-prefix-tree/

>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。
>
>**示例:**
>
>```
>Trie trie = new Trie();
>
>trie.insert("apple");
>trie.search("apple");   // 返回 true
>trie.search("app");     // 返回 false
>trie.startsWith("app"); // 返回 true
>trie.insert("app");   
>trie.search("app");     // 返回 true
>```
>
>说明:
>
>你可以假设所有的输入都是由小写字母 a-z 构成的。
>保证所有输入均为非空字符串。

solution:

```C++
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }
    
    void insert(string word) {
        Trie* node = this;
        for (char c : word) {
            if (node->next[c-'a'] == NULL) {
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for (char c : word) {
            node = node->next[c - 'a'];
            if (node == NULL) {
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char c : prefix) {
            node = node->next[c-'a'];
            if (node == NULL) {
                return false;
            }
        }
        return true;
    }
};
```

分析：

```c++
Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。

为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：

struct TreeNode {
    VALUETYPE value;    //结点值
    TreeNode* children[NUM];    //指向孩子结点
};
而 Trie 的结点是这样的(假设只包含'a'~'z'中的字符)：

struct TrieNode {
    bool isEnd; //该结点是否是一个串的结束
    TrieNode* next[26]; //字母映射表
};
要想学会 Trie 就得先明白它的结点设计。我们可以看到TrieNode结点中并没有直接保存字符值的数据成员，那它是怎么保存字符的呢？

这时字母映射表next 的妙用就体现了，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：

for (int i = 0; i < 26; i++) {
    char ch = 'a' + i;
    if (parentNode->next[i] == NULL) {
        说明父结点的后一个字母不可为 ch
    } else {
        说明父结点的后一个字母可以是 ch
    }
}

Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。

查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。

Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)。
```





### 词典中最长的单词

题目：https://leetcode-cn.com/problems/longest-word-in-dictionary/

>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。
>
>若无答案，则返回空字符串。
>
>示例 1:
>
>输入: 
>words = ["w","wo","wor","worl", "world"]
>输出: "world"
>解释: 
>单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
>示例 2:
>
>输入: 
>words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
>输出: "apple"
>解释: 
>"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。
>注意:
>
>所有输入的字符串都只包含小写字母。
>words数组长度范围为[1,1000]。
>words[i]的长度范围为[1,30]。

**注意**：如果这个有ab,abc，那么是不可以的，因为没有a，也就是说必须最长字母的每一个非空子串都在words里面。

solution:

**排序+hashset法**

```C++
class Solution {
public:
    string longestWord(vector<string>& words) {
        unordered_set<string> hashset;
        string max_word = "";
        if(words.size()==0) return max_word;
        sort(words.begin(), words.end());
        hashset.insert("");
        for(int i=0;i<words.size();i++){
            string word = words[i];
            word.erase(word.size()-1);
            if(hashset.count(word)>0){
                hashset.insert(words[i]);
                if(words[i].size()>max_word.size()) max_word = words[i];
                else if(words[i].size()==max_word.size())
                    max_word = max_word<words[i] ? max_word : words[i];
            }
        }
        return max_word;
    }
};
```

分析：

1. 先对words进行排序
2. 可以用一个hashset保存字符串（首先加入一个空串，便于长度为1的字符串和大于1的字符串同等处理），如果能找到这个字符串的子串（除去末尾最后一个字符），则将该字符串加入set;
3. 同时保存最长字符串，如果字符串长度相等，则返回字典序小的那个

**字典树法**

```C++
class Trie{
private:
    bool is_string;
    Trie *next[26];
public:
    Trie(){
        is_string=false;
        memset(next,0,sizeof(next));
    }
    
    void insert(string word){
        Trie *root=this;
        for(const auto& w:word){
            if(root->next[w-'a']==nullptr)
                root->next[w-'a']=new Trie();
            root=root->next[w-'a'];
        }
        root->is_string=true;
    }
    
    bool search(string word){
        Trie *root=this;
        for(const auto& w:word){
            //当节点值存在时，判断该节点是否表示为一个字符串，不是的话，直接返回false,否则继续循环;当节点值不存在时直接返回false
            if(root->next[w-'a']==nullptr||root->next[w-'a']->is_string==false)
                return false;
            root=root->next[w-'a'];
        }
        return true;
    }
};
class Solution {
public:
    string longestWord(vector<string>& words) {
        if(words.size()==0)return "";
        Trie* root=new Trie();
        //第一次遍历，建立前缀树
        for(const auto& word:words)
            root->insert(word);
        string result="";
        //第二次遍历，寻找最长单词
        for(const auto& word:words){
            if(root->search(word)){
                if(word.size()>result.size())result=word;//更新最长单词
                else if(word.size()==result.size()&&word<result)result=word;//长度相等的单词，取字典序小的单词
            }    
        }
        return result;
    }
};
```

### 最长单吃

题目：https://leetcode-cn.com/problems/longest-word-lcci/

>给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。
>
>示例：
>
>输入： ["cat","banana","dog","nana","walk","walker","dogwalker"]
>输出： "dogwalker"
>解释： "dogwalker"可由"dog"和"walker"组成。
>

solution：

```C++
class Solution {
public:
    struct TRIE{
        bool end;
        TRIE *next[26];
        TRIE(bool val){
            end=val;
            memset(next,0,sizeof(next));
        }
    };
    
    TRIE *wordtree = new TRIE(false);

    void insert(string word){
        TRIE *curr = wordtree;
        if(word.size()<=0)return;
        for(int i=0; i<word.size();i++){
            int j = word[i]-'a';
            if(curr->next[j]==NULL){
                curr->next[j] = new TRIE(false);
            }
            curr = curr->next[j];
        }
        curr->end = true;

    }

    bool search(string word, int index, int count){
        TRIE *curr = wordtree;
        for(int i=index; i<word.size();i++){
            int j = word[i]-'a';
            if(curr->next[j]==NULL)return false;
            if((curr->next[j])->end){
                if(search(word,i+1,count+1))return true;
            }
            curr = curr->next[j];
        }
        if(index == word.size())return count>1;
        return false;
    }

    string longestWord(vector<string>& words) {
        for(string word:words)insert(word);
        string res;
        for(string word:words){
            if(word.size()<res.size())continue;
            if(word.size()==res.size() && res<=word)continue;
            if(search(word,0,0)){
                res = word;
            }
        }
        return res;
    }
};
```



# 回文

## Palindrome Number 回文数

题目：https://leetcode-cn.com/problems/palindrome-number/

>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
>
>**示例 1:**
>
>```
>输入: 121
>输出: true
>```
>
>**示例 2:**
>
>```
>输入: -121
>输出: false
>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
>```
>
>**示例 3:**
>
>```
>输入: 10
>输出: false
>解释: 从右向左读, 为 01 。因此它不是一个回文数。
>```

solution：

```c++
    public class Solution {
        bool isPalindrome(int x) {
            if(x<0) return false;
            int len=0;
            int temp=x;
            int large=1;
            while(temp>=10){
                large = large*10;
                temp = temp/10;
            }
            while(x>0){
                if(x/large != x%10) return false;
                else{
                    x = x % large;
                    x = x / 10;
                    large = large /100;
                }
            }
            return true;
        }
    }
```

## 判断是否可以形成回文字符串

```c++
    class solution{
    public:
        bool isPalindrome(string str) {
            int count = 0;
            unordered_map<char, int> map;
            for(auto s : str) {
                map[s]++;
            }
            for(auto i = map.begin(); i != map.end(); i++) {
                if(i->second % 2) {
                    count++;
                }
            }
            return count == 0 || (str.size() % 2 == 1 && count == 1);
        }
    }
```

## Palindrome Linked List

题目：https://leetcode-cn.com/problems/palindrome-linked-list/

> 请判断一个链表是否为回文链表。
>
> **示例 1:**
>
> ```
> 输入: 1->2
> 输出: false
> ```
>
> **示例 2:**
>
> ```
> 输入: 1->2->2->1
> 输出: true
> ```

​		solution:

```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode(int x) : val(x), next(NULL) {}
     * };
     */
    class Solution {
    public:
        ListNode* reverse(ListNode* node) {
            ListNode* temp = NULL;
            ListNode* pre = NULL;
            while(node) {
                temp = node->next;
                node->next = pre;
                pre = node;
                node = temp;
            }
            return pre;
        }
        bool isPalindrome(ListNode* head) {
            if(head == NULL || head->next == NULL)
                return true;
            ListNode* fast = head;
            ListNode* slow = head;
            while(fast && fast->next) {
                fast = fast->next->next;
                slow = slow->next;
            }
            //考虑到奇数个节点
            if(fast) {
                slow = slow->next;
            }
            slow = reverse(slow);
            
            while(slow) {
                if(head->val == slow->val) {
                    head = head->next;
                    slow = slow->next;
                } else {
                    return false;
                }
            }
            return true;
        }
    };
```

## 最长回文字符串长度

题目：https://leetcode-cn.com/problems/longest-palindromic-substring/

>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
>
>**示例 1：**
>
>```
>输入: "babad"
>输出: "bab"
>注意: "aba" 也是一个有效答案。
>```
>
>**示例 2：**
>
>```
>输入: "cbbd"
>输出: "bb"
>```

solution：

```c++
    class Solution {
    public:
        int longestPalindrome(string s) {
            unordered_map<char, int> map;
            bool flag = false;
            int res = 0;
            for(auto c : s) {
                map[c]++;
            }
            for(auto i = map.begin(); i != map.end(); i++) {
                res += i->second;
                if(i->second % 2 == 1) {
                    res -= 1;
                    flag = true;
                }
            }
            return flag ? res + 1: res;
        }
    };
```

**note**: 奇数个字符只能有一个是奇数

# 全排列

## 字符串的排列 回溯法

题目：

>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。
>
>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。
>
>回文串不一定是字典当中的单词。
>
> 
>
>**示例1**：
>
>```
>输入："tactcoa"
>输出：true（排列有"tacocat"、"atcocta"，等等）
>```



solution：

```c++
    void swap(char* c1,char* c2){
        char tmp=*c1;
        *c1=*c2;
        *c2=tmp;
    }
     
    void permutation(char* pstr,char* pbegin){
        if(*pbegin=='\0')
            printf("%s\n",pstr);
        else{
            for(char* pCh=pbegin;*pCh!='\0';pCh++){
                swap(pbegin,pCh);
                permutation(pstr,pbegin+1);
                swap(pbegin,pCh);
            }
        }
    }
     
    void permutationStr(char* pstr){
        if(pstr==NULL)
            return;
        permutation(pstr,pstr);
    }
```

**note**: 第二个swap是为了还原字符串顺序， pbegin+1

## 无重复元素数组全排列

题目：

>给定一个 没有重复 数字的序列，返回其所有可能的全排列。
>
>**示例:**
>
>```
>输入: [1,2,3]
>输出:
>[
>  [1,2,3],
>  [1,3,2],
>  [2,1,3],
>  [2,3,1],
>  [3,1,2],
>  [3,2,1]
>]
>```



solution：

```c++
    class Solution {
    public:
        vector<vector<int>> permute(vector<int>& nums) {
            vector<vector<int>> res;
            if(nums.size() == 0) {
                return res;
            } else {
                permutation(nums, 0, res);
            }
            return res;
        }
        
        void permutation(vector<int>& nums, int begin, vector<vector<int>>& res) {
            if(nums.size() <= begin) {
                res.push_back(nums);
                return;
            }
            for(int i = begin; i < nums.size(); i++) {
                swap(nums, begin, i);
                permutation(nums, begin + 1, res);
                swap(nums, begin, i);
            }
        }
        void swap(vector<int>& nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    };
```

## 有重复元素数据全排列

题目：https://leetcode-cn.com/problems/permutations-ii/

>给定一个可包含重复数字的序列，返回所有不重复的全排列。
>
>**示例:**
>
>```
>输入: [1,1,2]
>输出:
>[
>  [1,1,2],
>  [1,2,1],
>  [2,1,1]
>]
>```

solution：

```c++
    class Solution {
    public:
        vector<vector<int>> permuteUnique(vector<int>& nums) {
            set<vector<int>> res;
            permutation(nums, 0, res);
            return vector<vector<int>> (res.begin(), res.end());
        }
        
        void permutation(vector<int>& nums, int begin, set<vector<int>>& res) {
            if(nums.size() <= begin) {
                res.insert(nums);
                return;
            }
            unordered_map<int,bool> used;
            for(int i = begin; i < nums.size(); i++) {
                if(i != begin && nums[i] == nums[begin] && used[nums[i]]) { //此部分剪枝
                    continue;
                }
                used[nums[i]] = true;
                swap(nums, begin, i);
                permutation(nums, begin + 1, res);
                swap(nums, begin, i);
            }
        }
        void swap(vector<int>& nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    };       
```

## 数字内组合得到下一个比该数大的数Next Permutation

题目：https://leetcode-cn.com/problems/next-permutation/

>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
>必须原地修改，只允许使用额外常数空间。
>
>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
>1,2,3 → 1,3,2
>3,2,1 → 1,2,3
>1,1,5 → 1,5,1

solution:

```c++
    class Solution {
    public:
        void nextPermutation(vector<int>& nums) {
            int j,len=nums.size(),i=len-1,tmp;
            //找出第一个逆序位置
            while(i>0 &&  nums[i]<=nums[i-1])i--;
            if(i>0){
                j=len-1;
                //找出第一个比逆序位置大的数的位置
                while(j>=i && nums[j]<=nums[i-1])j--;
                tmp=nums[i-1];
                nums[i-1]=nums[j];
                nums[j]=tmp;
            }
            j=len-1;
            //对调i-1之后的元素
            while(i<j){
                tmp=nums[i];
                nums[i]=nums[j];
                nums[j]=tmp;
                i++;j--;
            }
        }
    };
```

# 回文全排列

## 给出无重复所有回文全排列

题目：https://leetcode-cn.com/problems/permutations/

>给定一个 没有重复 数字的序列，返回其所有可能的全排列。
>
>**示例:**
>
>```
>输入: [1,2,3]
>输出:
>[
>  [1,2,3],
>  [1,3,2],
>  [2,1,3],
>  [2,3,1],
>  [3,1,2],
>  [3,2,1]
>]
>```
>
>

solution：

```c++
    class Solution{
    public:
        vector<string> findAllPalindrome(string str) {
            unordered_map<char, int> map;
            unodered_set<string> res;
            string t = "", mid = "";
            for(auto s : str) {
                map[s]++;
            }
            for(auto i = map.begin(); i != map.end(); i++) {
                if(i->second % 2 == 1) {
                    mid += i->first;
                }
                t += string(i->second / 2, i->first);
            }
            if(mid.size() > 1) return {};
            permute(t, 0, mid, res);
            return vector<string>(res.begin(), res.end()); 
        }
        void permute(string &t, int start, string mid, unodered_set<string> &res) {
            if(start >= t.size()) {
                res.insert(t + mid + string(t.rbegin(), t.rend()));
            }
            for(int i = start; i < t.size(); i++) {
                if(i != start && t[i] == t[start]) {
                    continue;
                }
                swap(t[i], t[start]);
                permute(t, start + 1, mid, res);
                swap(t[i], t[start]);
            }
        }
    };
```



# 动态规划

## 最小路径和

题目：https://leetcode-cn.com/problems/minimum-path-sum/

>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
>说明：每次只能向下或者向右移动一步。
>
>示例:
>
>输入:
>[
>  [1,3,1],
>  [1,5,1],
>  [4,2,1]
>]
>输出: 7
>解释: 因为路径 1→3→1→1→1 的总和最小。

solution:

```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int rows = grid.size();
        if(rows == 0)
            return 0;
        int columns = grid[0].size();
        for(int i=0; i<rows; i++) {
            for(int j=0; j<columns; j++) {
                if(i==0 && j==0) {
                    continue;
                }
                else if(i==0 && j!=0){
                    grid[i][j] = grid[i][j-1] + grid[i][j];
                }
                else if(i!=0 && j==0){
                    grid[i][j] = grid[i-1][j] + grid[i][j];
                }
                else {
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j];
                }
            }
        }
        return grid[rows-1][columns-1];
    }
};
```

分析：

* 状态定义：

  设 `dp `为大小` m×n` 矩阵，其中 `dp[i][j]` 的值代表直到走到 `(i,j) `的最小路径和。

* 转移方程：

  题目要求，只能向右或向下走，换句话说，当前单元格` (i,j) `只能从上方单元格 `(i-1,j)` 或左方单元格 `(i,j-1)`走到，因此只需要考虑矩阵左边界和上边界。

  走到当前单元格 `(i,j)` 的最小路径和` =` “从上方单元格 `(i-1,j) `与 从左方单元格 `(i,j-1)`走来的 两个最小路径和中较小的 ” `+`当前单元格值 `grid[i][j] `。具体分为以下 44 种情况：
  1) 当左边和上边都不是矩阵边界时： 即当$$i \neq 0,  j \not= 0$$时$$dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] $$
  2) 当只有上边是矩阵边界时： 只能从上面来，即当$$i = 0, j \not= 0$$时，$$dp[i][j] = dp[i][j - 1] + grid[i][j]；$$
  3) 当只有左边是矩阵边界时： 只能从左面来，即当$$i \not= 0, j = 0$$时， $$dp[i][j] = dp[i - 1][j] + grid[i][j]$$；
  4) 当左边和上边都是矩阵边界时： 即当$$i = 0, j = 0$$时，其实就是起点， $$dp[i][j] = grid[i][j];$$

* 初始状态：

  `dp`初始化即可，不需要修改初始 0值。

* 返回值：

  返回 `dp`矩阵右下角值，即走到终点的最小路径和。

* 其实我们完全不需要建立 `dp `矩阵浪费额外空间，直接遍历 $$grid[i][j]$$修改即可。这是因为：$$grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；$$原 `grid` 矩阵元素中被覆盖为 `dp` 元素后（都处于当前遍历点的左上方），**不会再被使用到**。
* 复杂度分析：
  时间复杂度 $$O(M \times N) $$： 遍历整个 `grid`矩阵元素。
  空间复杂度 $$O(1)$$ ： 直接修改原矩阵，不使用额外空间。

## 不同路径

题目：https://leetcode-cn.com/problems/unique-paths/

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>问总共有多少条不同的路径？
>
>例如，上图是一个7 x 3 的网格。有多少可能的路径？
>
>**示例 1:**
>
>```
>输入: m = 3, n = 2
>输出: 3
>解释:
>从左上角开始，总共有 3 条路径可以到达右下角。
>
>1. 向右 -> 向右 -> 向下
>2. 向右 -> 向下 -> 向右
>3. 向下 -> 向右 -> 向右
>```
>
>**示例 2:**
>
>```
>输入: m = 7, n = 3
>输出: 28
>```
>
>
>提示：
>
>1 <= m, n <= 100
>题目数据保证答案小于等于 2 * 10 ^ 9

solution:

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int count = 0;
        vector<int> arr(n, 1);  //必须是初始化为1
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(i==0 && j!=0){
                    arr[j] = arr[j-1];
                }
                else if(i!=0 && j==0){
                    arr[j] = arr[j];
                }
                else if(i!=0 && j!=0) {
                    arr[j] = arr[j-1] + arr[j];
                }
            }
        }
        return arr[n-1];
    }
};
```

分析：

* 利用动态规划, 借助一维数组,时间复杂度 $$O(M \times N) $$， 空间复杂度 $$O(N)$$ 

* 可以利用数学法，排列组合：$$C^{n-1}_{m+n-2}$$或者$$C^{m-1}_{m+n-2}$$

  ```c++
  class Solution {
  public:
  int uniquePaths(int m, int n) {
  	if (m == 1 || n == 1)
  		return 1;
  	if (m > n)
  		swap(m, n);//保证m<=n
  	//计算阶乘：不用调用函数，节省空间
  	unsigned long long int temp = 1;
  	unsigned long long int result = 1;
  	for (int i = 1; i <= m-1 ; i++)
  	{
  		temp *= i;
  	}
  	for (int i = n; i <= m + n - 2; i++)
  	{
  		result *= i;
  	}
  	result = result / temp;
  	return result;
  }
  };
  ```

  即一共有m行n列，其中需要向下走m-1步，向右走n-1步，一共走m+n-2步。所以就是在m+n-2步中选出哪m-1步是向下走的，其余自动为向右走的步数。

## 不同路径II

题目：https://leetcode-cn.com/problems/unique-paths-ii/

>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
>网格中的障碍物和空位置分别用 1 和 0 来表示。
>
>说明：m 和 n 的值均不超过 100。
>
>**示例 1:**
>
>```c++
>输入:
>[
>  [0,0,0],
>  [0,1,0],
>  [0,0,0]
>]
>输出: 2
>解释:
>3x3 网格的正中间有一个障碍物。
>从左上角到右下角一共有 2 条不同的路径：
>
>1. 向右 -> 向右 -> 向下 -> 向下
>2. 向下 -> 向下 -> 向右 -> 向右
>```
>
>

solution:

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        if(rows == 0)
            return 0;
        int columns = obstacleGrid[0].size();
        for(int i=0; i<rows; i++) {
            for(int j=0; j<columns; j++) {
                if(obstacleGrid[i][j] == 1){
                    obstacleGrid[i][j] = 0;
                    continue;
                }
               // 判断是否有障碍物，若有，当前点对结果贡献为0，直接置0即可。
                if(i==0 && j==0) {
                    obstacleGrid[i][j] = 1;// 将第一个格点赋初始值1；
                }
                else if(i==0 && j!=0){
                    obstacleGrid[i][j] = obstacleGrid[i][j-1];
                }
                else if(i!=0 && j==0){
                    obstacleGrid[i][j] = obstacleGrid[i-1][j];
                }
                else {
                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];
                }
            }
        }
        return obstacleGrid[rows-1][columns-1];
    }
};
```

分析：

* 利用动态规划, 借助原数组,时间复杂度 $$O(M \times N) $$， 空间复杂度 $$O(1)$$ 

## 不同路径III

题目：https://leetcode-cn.com/problems/unique-paths-iii/

>在二维网格 grid 上，有 4 种类型的方格：
>
>1 表示起始方格。且只有一个起始方格。
>2 表示结束方格，且只有一个结束方格。
>0 表示我们可以走过的空方格。
>-1 表示我们无法跨越的障碍。
>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。
>
> **示例 1：**
>
>```
>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
>输出：2
>解释：我们有以下两条路径：
>
>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
>2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
>```
>
>**示例 2：**
>
>```
>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
>输出：4
>解释：我们有以下四条路径： 
>
>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
>2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
>3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
>4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
>```
>
>**示例 3：**
>
>```
>输入：[[0,1],[2,0]]
>输出：0
>解释：
>没有一条路能完全穿过每一个空的方格一次。
>请注意，起始和结束方格可以位于网格中的任意位置。
>```

solution:

* 方法一：回溯深度优先搜索

  思路与算法

  让我们尝试遍历每一个 0 方格，并在走过的方格里留下一个障碍。回溯的时候，我们要删除那些自己留下的障碍。介于输入数据的限制，这个方法是可以通过的，因为一个不好的路径很快就会因没有无障碍的方格可以走而被卡住。

  


* 方法二：动态规划

  思路与算法

  让我们定义 dp(r, c, todo) 为从 (r, c) 开始行走，还没有遍历的无障碍方格集合为 todo 的好路径的数量。可以使用一个与 方法一 类似的方法，并通过记忆化状态 (r, c, todo) 的答案来避免重复搜索。其他

## 素数

题目：如何高效寻找素数

[https://github.com/labuladong/fucking-algorithm/blob/master/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/%E6%89%93%E5%8D%B0%E7%B4%A0%E6%95%B0.md](https://github.com/labuladong/fucking-algorithm/blob/master/高频面试系列/打印素数.md)

solution：

```c++
int countPrimes(int n) {
    boolean[] isPrim = new boolean[n];
    Arrays.fill(isPrim, true);
    for (int i = 2; i * i < n; i++) //优化
        if (isPrim[i]) 
            for (int j = i * i; j < n; j += i) //优化2
                isPrim[j] = false;
    
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrim[i]) count++;
    
    return count;
}
```

注：

* 判断一个数是否是素数的 `isPrime` 函数，由于因子的对称性，其中的 for 循环只需要遍历 `[2,sqrt(n)]` 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 `sqrt(n)`

* 比如 `n = 25`，`i = 4` 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 `i = 2` 和 `i = 3` 的 2 × 4 和 3 × 4 标记了。

## Pow(x, n)

题目：https://leetcode-cn.com/problems/powx-n/

>
>
>实现 pow(x, n) ，即计算 x 的 n 次幂函数。
>
>**示例 1:**
>
>```
>输入: 2.00000, 10
>输出: 1024.00000
>```
>
>**示例 2:**
>
>```
>输入: 2.10000, 3
>输出: 9.26100
>```
>
>**示例 3:**
>
>```
>输入: 2.00000, -2
>输出: 0.25000
>```
>
>解释: 2-2 = 1/22 = 1/4 = 0.25
>
>说明:
>
>-100.0 < x < 100.0
>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

solution:

```C++
    class Solution {
    public:
        double myPow(double x, int n) {
            if(n == 0) {
                return 1.0;
            } 
            if(n < 0) {
                return 1 / x * myPow(1 / x, - (n + 1));
            } 
            return n & 1 == 1 ? x * myPow(x * x, n / 2) : myPow(x * x, n / 2);
        }
    };
```

分析：

* 此方法利用的是**快速幂 + 递归**

* 当我们要计算 $x^n$时，我们可以先递归地计算出 $y = x^{\lfloor n/2 \rfloor}$其中 $\lfloor a \rfloor$ 表示对 $a$ 进行下取整；

* 根据递归计算的结果，如果 $n$为偶数，那么 $x^n = y^2$;如果 $n$为奇数，那么$ x^n = y^2 * x$；

* 递归的边界为 $n = 0$，任意数的0次方均为 1。

* 由于每次递归都会使得指数减少一半，因此递归的层数为$ O(\log n)$，算法可以在很快的时间内得到结果

* 时间复杂度：$O(logn)$，即为递归的层数。

  空间复杂度：$O(\log n)$，即为递归的层数。这是由于递归的函数调用会使用栈空间。

* 优化：**快速幂 + 迭代**可以时间复杂度不变，空间复杂度为$O(1)$

## 用队列实现栈

题目：https://leetcode-cn.com/problems/implement-stack-using-queues/

>
>
>使用队列实现栈的下列操作：
>
>push(x) -- 元素 x 入栈
>pop() -- 移除栈顶元素
>top() -- 获取栈顶元素
>empty() -- 返回栈是否为空
>注意:
>
>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

solution:

```c++
class MyStack {
private:
    queue<int> q;
    int size;
public:
    /** Initialize your data structure here. */
    MyStack() {
        size = 0;
    }
    
    /** Push element x onto stack. */
    void push(int x) {
        q.push(x);
        size++;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        for(int i=1; i< size; i++){
            q.push(q.front());
            q.pop();
        }
        int res = q.front();
        q.pop();
        size--;
        return res;
    }
    
    /** Get the top element. */
    int top() {
        return q.back();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return q.empty();
    }
};
```

## 用栈实现队列

题目：https://leetcode-cn.com/problems/implement-queue-using-stacks/

>使用栈实现队列的下列操作：
>
>push(x) -- 将一个元素放入队列的尾部。
>pop() -- 从队列首部移除元素。
>peek() -- 返回队列首部的元素。
>empty() -- 返回队列是否为空。
>示例:
>
>MyQueue queue = new MyQueue();
>
>queue.push(1);
>queue.push(2);  
>queue.peek();  // 返回 1
>queue.pop();   // 返回 1
>queue.empty(); // 返回 false
>说明:
>
>你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

solution：

```c++
class MyQueue {
private:
    stack<int> s1, s2;
public:
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int ret = s2.top();
        s2.pop();
        return ret;
    }
    
    /** Get the front element. */
    int peek() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int ret = s2.top();
        return ret;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```



# 附录

https://github.com/labuladong/fucking-algorithm