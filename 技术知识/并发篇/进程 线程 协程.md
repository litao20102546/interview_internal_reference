# 进程

* 系统分配资源的基本单位
* 隔离堆和栈, 有独立的地址空间
* 切换开销：（大， 栈、寄存器、虚拟内存、文件句柄等）
* 适合CPU密集型
* 同步
* 不同进程通过进程间通信来通信
* 安全性：高

# 线程 

* 线程是进程的一个实体， CPU调度和分配的基本单位
* 隔离栈共享堆， 拥有资源少(如程序计数器,一组寄存器和栈)
* 切换开销：快，小
* 适合IO密集型
* 同步
* 不同线程通信通过共享内存，有全局唯一锁
* 安全性：当前线程挂掉会影响同在一个进程的所有线程
* 一个进程在其执行的过程中可以产生多个线程。

# 协程

* 协程是一种用户态的轻量级线程， 协程的调度完全由用户控制
* 切换开销：快,小, 将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
* 有独立寄存器和栈
* 适合IO密集型
* 异步, 事件调用  gevent.spawn goroutine
* 可以不加锁的访问全局变量
* 不能利用多核CPU   通常多进程+协程



# 多进程通信

* 管道

  * 管道是Linux支持的最初Unix IPC形式之一，具有以下特点：
    * 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
    * 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；
    * 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
    * 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

  * 管道的局限：
    * 只支持单向数据流；
    * 只能用于具有亲缘关系的进程之间；
    *  没有名字；
    * 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
    * 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式。
  * who│wc -l 或者int pipe(int fd[2])

* 有名管道（FIFO）

  * FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。
  * int mkfifo(const char * pathname, mode_t mode)

* 消息队列
  * rabbitmq
  * kafka
  * zeromq
  * rocketmq
  * 消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

* 信号量

  * 共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

  * 信号是异步的，一个进程不必通过任何操作来等待信号的到达
  * 信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。

* 套接字
* 共享内存
  * 这个通信方式就可以很好着解决拷贝所消耗的时间了。系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了。
  * 速度最快，效率最高的进程间通信方式，进程之间直接访问内存，而不是通过传送数据。但是使用共享内存需要自己提供同步机制。

# 进程线程状态

* 进程5状态
  https://www.cnblogs.com/toria/p/11234323.html

* 线程8状态:

1. New （新建状态）

   使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

2. Runnable（可运行）

   当线程对象调用了start()方法之后，该线程就进入可运行状态可运行状态的线程处于可运行队列中，要等待JVM里线程调度器的调度。

3. Running

   如果可运行状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

4. ready（就绪状态）

   yield 后进入就绪状态

5. blocked

   线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)。

6. waiting

   运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。

7. time_waiting（超时等待）

   通过调用线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。

8. terminated（终止状态）
   一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

# 什么是上下文切换
即使单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。（时间片一般是几十毫秒）

　　CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到加载的过程就是一次上下文切换。上下文切换会影响多线程的执行速度

# sleep() 方法和 wait() 方法区别和共同点

* 相同点：
	两者都可以暂停线程的执行，都会让线程进入等待状态。
* 不同点：
	sleep()方法没有释放锁，而 wait()方法释放了锁。
	sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。
	执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/20.并发篇/线程状态.png" alt="状态转换图" style="zoom:80%;" />

![线程资源](/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/20.并发篇/线程资源结构图.png)



wait, sleep, yield, join demo对比 ：https://blog.csdn.net/ywlmsm1224811/article/details/94022647

* **wait**

  wait 方法是属于 **Object** 类中的，wait 过程中线程会释放对象锁，只有当其他线程调用 notify 才能唤醒此线程。wait 使用时必须先获取对象锁，即必须在 **synchronized** 修饰的代码块中使用，那么相应的 notify 方法同样必须在 synchronized 修饰的代码块中使用，如果没有在synchronized 修饰的代码块中使用时运行时会抛出IllegalMonitorStateException的异常

* **sleep**

  sleep 方法是属于 ***\*Thread\**** 类中的，sleep 过程中线程**不会释放锁**，只会***\*阻塞线程\****，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态，***\*可中断\****，sleep 给其他线程运行机会时不考虑线程的优先级，因此***\*会给低优先级的线程以运行的机会\****

* ### yield

  和 sleep 一样都是 **Thread** 类的方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和 sleep 不同的是 yield方法并**不会让线程进入阻塞状态**，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。还有一点和 sleep 不同的是 yield 方法只能使**同优先级或更高优先级**的线程有执行的机会。

* **join**

  等待调用join方法的线程结束之后，程序再继续执行，一般用于***\*等待异步线程执行完结果之后才能继续运行的场景\****。例如：主线程创建并启动了子线程，如果子线程中药进行大量耗时运算计算某个数据值，而主线程要取得这个数据值才能运行，这时就要用到 join 方法了

# 僵尸进程

- 一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程被称为僵尸进程。ps命令将僵尸进程的状态打印为Z。

- 如果父进程在子进程之前终止，则所有的子进程的父进程都会改变为init进程，我们称这些进程由init进程领养。这时使用ps命令查看后可以看到子进程的父进程ppid已经变为了1。

- 当子进程终止时，内核就会向它的父进程发送一个SIGCHLD信号，父进程可以选择忽略该信号，也可以提供一个接收到信号以后的处理函数。对于这种信号的系统默认动作是忽略它。

- 我们不希望有过多的僵尸进程产生，所以当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。

  