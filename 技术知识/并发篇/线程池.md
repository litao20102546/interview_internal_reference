# 线程池是什么?

简单看名字就知道是装有线程的池子，我们可以把要执行的多线程交给线程池来处理，和连接池的概念一样，通过维护一定数量的线程池来达到多个线程的复用。

# 线程池的优点

* 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；
* 提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；
* 方便线程并发数的管控。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））。
* 提供更强大的功能，延时定时线程池。

# 常见的线程池

* newCachedThreadPool 创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
* newFixedThreadPool 创建一个定长线程池，可控制最大并发数，超出的线程将在队列中等待。
* newScheduledThreadPool 创建一个定时线程池，支持定时及周期性的执行任务。
* newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序执行(FIFO,LIFO)。

# 线程池中的几种重要的参数

* corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收。
* maximumPoolSize就是线程池中可以容纳的最大线程的数量。
* keepAliveTime，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间，util，就是计算这个时间的一个单位。
* workQueue，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFO原则(先进先出)。
* threadFactory，就是创建线程的线程工厂。
* handler,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。

# 线程池的拒绝策略

ThreadPoolExecutor中已经包含四种处理策略。

* AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。
* CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。
* DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。
* DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。
* 自定义

# 初始化线程池时线程数的选择

* 如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。

* 如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。

上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。

# 线程池工作流程

1. 如果线程池中的线程小于corePoolSize时就会创建新线程直接执行任务。
2. 如果线程池中的线程大于corePoolSize时就会暂时把任务存储到工作队列workQueue中等待执行。
3. 如果工作队列workQueue也满时：当线程数小于最大线程池数maximumPoolSize时就会创建新线程来处理，而线程数大于等于最大线程池数maximumPoolSize时就会执行拒绝策略。

# 线程池都有哪几种工作队列

* ArrayBlockingQueue

  是一个基于数组结构的有界阻塞队列，此队列按 FIFO(先进先出)原则对元素进行排序。

* LinkedBlockingQueue

  一个基于链表结构的阻塞队列，此队列按FIFO (先进先出) 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

* 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

* PriorityBlockingQueue

  一个具有优先级的无限阻塞队列。

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/20.并发篇/线程池逻辑架构.jpeg" alt="线程池逻辑架构图" style="zoom:100%;" />

# 提交线程

提交一个线程可以用这两种方式submit和execute区别

* execute没有返回值，如果不需要知道线程的结果就使用execute方法，性能会好很多。

* submit返回一个Future对象，如果想知道线程结果就使用submit提交，而且它能在主线程中通过Future的get方法捕获线程中的异常。

# 关闭线程

* es.shutdown();

  不再接受新的任务，之前提交的任务等执行结束再关闭线程池。

* es.shutdownNow();

  不再接受新的任务，试图停止池中的任务再关闭线程池，返回所有未处理的线程list列表。