https://blog.csdn.net/u013616945/article/details/77435607

## 内存管理的必要性
出现在早期的计算机系统当中，程序是直接运行在物理内存中，每一个程序都能直接访问物理地址。如果这个系统只运行一个程序的话，并且这个程序所需的内存不要超过该机器的物理内存就不会出现问题。但是如今的系统都是支持多任务和多进程的，那么这时我们就要考虑如何将系统内有限的物理内存及时有效的分配给多个程序了，这就是内存管理的基本概念。顾名思义就是是记录哪些内存是正在使用的，哪些内存是空闲的；在进程需要时为其分配内存，在进程使用完后释放内存。

## 内存管理的例子
假如我们有三个程序，程序A，B，C，程序A运行的过程中需要10M内存，程序B运行的过程中需要100M内存，而程序C运行的过程中需要20M内存。如果系统同时需要运行程序A和B，那么早期的内存管理过程大概是这样的，将物理内存的前10M分配给A，接下来的10M-110M分配给B。这种内存管理的方法比较直接，好了，假设我们这个时候想让程序C也运行，同时假设我们系统的内存只有128M，显然按照这种方法程序C由于内存不够是不能够运行的。大家知道可以使用虚拟内存的技术，内存空间不够的时候可以将程序不需要用到的数据交换到磁盘空间上去，已达到扩展内存空间的目的。下面我们来看看这种内存管理方式存在的几个比较明显的问题。
　　1．进程地址空间不能隔离
　　由于程序直接访问的是物理内存，这个时候程序所使用的内存空间不是隔离的。举个例子，就像上面说的A的地址空间是0-10M这个范围内，但是如果A中有一段代码是操作10M-128M这段地址空间内的数据，那么程序B和程序C就很可能会崩溃（每个程序都可以访问系统的整个地址空间）。这样很多恶意程序或者是木马程序可以轻而易举地破快其他的程序，系统的安全性也就得不到保障了，这对用户来说也是不能容忍的。

　　2. 内存使用的效率低
　　如上面提到的，如果我们要像让程序A、B、C同时运行，那么唯一的方法就是使用虚拟内存技术将一些程序暂时不用的数据写到磁盘上，在需要的时候再从磁盘读回内存。这里程序C要运行，将A交换到磁盘上去显然是不行的，因为程序是需要连续的地址空间的，程序C需要20M的内存，而A只有10M的空间，所以需要将程序B交换到磁盘上去，而B足足有100M，可以看到为了运行程序C我们需要将100M的数据从内存写到磁盘，然后在程序B需要运行的时候再从磁盘读到内存，我们知道IO操作比较耗时，所以这个过程效率将会十分低下。
　　3. 程序运行的地址不能确定
　　程序每次需要运行时，都需要在内存中分配一块足够大的空闲区域，而问题是这个空闲的位置是不能确定的，这会带来一些重定位的问题，重定位的问题确定就是程序中引用的变量和函数的地址，如果有不明白童鞋可以去查查编译愿意方面的资料。
　　内存管理无非就是想办法解决上面三个问题，如何使进程的地址空间隔离，如何提高内存的使用效率，如何解决程序运行时的重定位问题？

# 基本内存管理方案
## 单一连续区
每次只运行一个用户程序，用户程序独占内存，总是被加载到同一个内存地址上。
特点：一段时间只有一个进程在内存，简单，内存利用率低

## 固定分区
系统把内存空间分割成若干个连续区域，每个区域称为分区；每个分区的大小可以相同也可以不同，分区大小固定不变，每个分区有且只能装一个进程。

## 可变分区
根据进程的需求，把可分配的内存空间分割出一个分区，分配给进程。这种管理方案可能出现一些很小的，不易利用的空闲去区，从而导致内存利用率的下降，可以考虑利用紧缩技术来解决这个问题，也就是在内存移动程序中，将所有小的空闲区合并成较大的空闲区。

## 页式存储管理方案
* 用户进程地址空间被划分成大小相等的部分，称为页或者页面，从0开始编号。

* 内存空间按同样的大小分成划分成大小相等的区域，称为页框。从0开始编号。

* 以页为单位来进行内存分配，按照进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。典型的页面尺寸是4K或4M。

  <img src=page.png style="zoom:33%;" />


从进程的地址空间转换到实际的内存空间是通过查页表项（记录了逻辑页与页框号的对应关系，每一个进程一个页表，存放在内存）来实现的。CPU取到逻辑地址，自动划分为页号和页内地址;用页号查页表，得到页框号，再与页内偏移拼接成物理地址。

## 段式存储管理方案

* 用户进程地址空间按照程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段名。

* 内存空间被动态划分成若干长度不相同的区域，称为物理段，每个物理段有起始地址和长度决定

* 内存分配规则：以段为单位进行分配，每段在内存占据连续空间，但各段之间可以不相邻。

* 逻辑地址为段号+段内地址。

  <img src=memory.png style="zoom:33%;" />


段表记录了段号，段首地址和段长度之间的关系，每个进程一个段表，存在内存。地址转换规则为CPU取到逻辑地址，用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址。

## 段页式存储管理方案

* 用户进程地址空间先按段进行划分，每一段再按页面进行划分。

* 内存空间：同页式存储方案。

* 内存分配规则：同页式存储方案。

* 逻辑地址如下：

  <img src= fragPage.png />

## 虚拟内存技术
基本思想：每个程序拥有自己的地址空间，这个空间被分割成很多个块，每一个块称为页面。每一页都有连续的地址范围。这些页被映射到物理内存，但并不是所有页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不再物理内存中的地址空间时，由操作系统（缺页异常）负责将缺失的部分装入物理内存并重新执行失败的指令。

## 缺页异常使用的常用页面置换算法

* 最佳页面置换算法（OPT）
* 先进先出算法（FIFO）
* 第二次机会算法（SCR）
* 时钟算法（clock）
* 最近未使用算法（NRU）
* 最近最少使用算法（LRU）
* 最不经常使用算法（NFU）
* 老化算法（aging）
* 工作集算法(working set)