# 进程

* 系统分配资源的基本单位
* 隔离堆和栈, 有独立的地址空间
* 切换开销：（大， 栈、寄存器、虚拟内存、文件句柄等）
* 适合CPU密集型
* 同步
* 不同进程通过进程间通信来通信
* 安全性：高

# 线程 

* 线程是进程的一个实体， CPU调度和分配的基本单位
* 隔离栈共享堆， 拥有资源少(如程序计数器,一组寄存器和栈)
* 切换开销：快，小
* 适合IO密集型
* 同步
* 不同线程通信通过共享内存，有全局唯一锁
* 安全性：当前线程挂掉会影响同在一个进程的所有线程
* 一个进程在其执行的过程中可以产生多个线程。

# 协程

* 协程是一种用户态的轻量级线程， 协程的调度完全由用户控制
* 切换开销：快,小, 将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，
* 有独立寄存器和栈
* 适合IO密集型
* 异步, 事件调用  gevent.spawn goroutine
* 可以不加锁的访问全局变量
* 不能利用多核CPU   通常多进程+协程

# 进程线程状态

* 进程5状态
  https://www.cnblogs.com/toria/p/11234323.html

* 线程8状态:

1. New （新建状态）

   使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。

2. Runnable（可运行）

   当线程对象调用了start()方法之后，该线程就进入可运行状态可运行状态的线程处于可运行队列中，要等待JVM里线程调度器的调度。

3. Running

   如果可运行状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

4. ready（就绪状态）

   yield 后进入就绪状态

5. blocked

   线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)。

6. waiting

   运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。

7. time_waiting（超时等待）

   通过调用线程的sleep()或join()发出了I/O请求时，线程就会进入到阻塞状态。当sleep()状态超时，join()等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。

8. terminated（终止状态）
   一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

# 什么是上下文切换
即使单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。（时间片一般是几十毫秒）

　　CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到加载的过程就是一次上下文切换。上下文切换会影响多线程的执行速度

# sleep() 方法和 wait() 方法区别和共同点

* 相同点：
	两者都可以暂停线程的执行，都会让线程进入等待状态。
* 不同点：
	sleep()方法没有释放锁，而 wait()方法释放了锁。
	sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。
	执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。

<img src="/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/20.并发篇/线程状态.png" alt="状态转换图" style="zoom:80%;" />

![线程资源](/Users/orangeli/litao/FindWork/interview_internal_reference/技术知识/20.并发篇/线程资源结构图.png)



wait, sleep, yield, join demo对比 ：https://blog.csdn.net/ywlmsm1224811/article/details/94022647

* **wait**

  wait 方法是属于 **Object** 类中的，wait 过程中线程会释放对象锁，只有当其他线程调用 notify 才能唤醒此线程。wait 使用时必须先获取对象锁，即必须在 **synchronized** 修饰的代码块中使用，那么相应的 notify 方法同样必须在 synchronized 修饰的代码块中使用，如果没有在synchronized 修饰的代码块中使用时运行时会抛出IllegalMonitorStateException的异常

* **sleep**

  sleep 方法是属于 ***\*Thread\**** 类中的，sleep 过程中线程**不会释放锁**，只会***\*阻塞线程\****，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态，***\*可中断\****，sleep 给其他线程运行机会时不考虑线程的优先级，因此***\*会给低优先级的线程以运行的机会\****

* ### yield

  和 sleep 一样都是 **Thread** 类的方法，都是暂停当前正在执行的线程对象，不会释放资源锁，和 sleep 不同的是 yield方法并**不会让线程进入阻塞状态**，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。还有一点和 sleep 不同的是 yield 方法只能使**同优先级或更高优先级**的线程有执行的机会。

* **join**

  等待调用join方法的线程结束之后，程序再继续执行，一般用于***\*等待异步线程执行完结果之后才能继续运行的场景\****。例如：主线程创建并启动了子线程，如果子线程中药进行大量耗时运算计算某个数据值，而主线程要取得这个数据值才能运行，这时就要用到 join 方法了