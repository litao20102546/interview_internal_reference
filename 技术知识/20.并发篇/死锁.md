死锁是由于两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。

1. 产生死锁的四个必要条件
   * 互斥性：线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。
   * 请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。
   * 不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。
   * 循环等待：发生死锁时，线程进入死循环，永久阻塞。
2. 产生死锁的原因
   * 竞争不可抢占性资源
      * p1已经打开F1，想去打开F2，p2已经打开F2，想去打开F1，但是F1和F2都是不可抢占的，这是发生死锁。
   * 竞争可消耗资源引起死锁
      * 进程间通信，如果顺序不当，会产生死锁，比如p1发消息m1给p2，p1接收p3的消息m3，p2接收p1的m1，发m2给p3，p3，以此类推，如果进程之间是先发信息的那么可以完成通信，但是如果是先接收信息就会产生死锁。
   * 进程推进顺序不当
      * 进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。
3. 避免死锁的方法
   * 破坏“互斥使用/资源独占”条件
      * 使用资源转换技术，将独占资源变为共享资源
   * 破坏“占有且等待”条件
      * 方案1：每个进程在运行前必须一次性的申请它所要求的全部资源，且仅当该进程所要的资源均可满足时才一次性的分配。
      * 资源利用率低，“饥饿”现象
      * 方案1：在允许进程动态申请资源的前提下规定，一个进行在申请新资源，且不能立即得到满足，必须释放已占有的全部资源。若需要再重新申请
   * 破坏“不可抢占”条件
      * 可以通过操作系统抢占这一资源（根据进程的不同优先级）
      * 局限性：适用于状态易于保存和恢复的资源，如CPU(抢占式的调度算法)，内存(页面置换算法)
   * 破坏“循环等待”条件
      * 通过定义资源类型的线性顺序实现
      * 方案：资源有序分配法。（如哲学家就餐问题）也就是把资源中所有的资源编号，进程在申请资源时，必须严格按照资源编号的递增次序进行，否则操作系统不予分配。（资源使用的频繁性？）