1. 死锁
   死锁是由于两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。
   1. 产生死锁的四个必要条件
      * 互斥性：线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。
      * 请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。
      * 不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。
      * 循环等待：发生死锁时，线程进入死循环，永久阻塞。
   2. 产生死锁的原因
      * 竞争不可抢占性资源
         * p1已经打开F1，想去打开F2，p2已经打开F2，想去打开F1，但是F1和F2都是不可抢占的，这是发生死锁。
      * 竞争可消耗资源引起死锁
         * 进程间通信，如果顺序不当，会产生死锁，比如p1发消息m1给p2，p1接收p3的消息m3，p2接收p1的m1，发m2给p3，p3，以此类推，如果进程之间是先发信息的那么可以完成通信，但如果是先接收信息就会产生死锁。
      * 进程推进顺序不当
         * 进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。
   3. 避免死锁的方法
      * 破坏“互斥使用/资源独占”条件
         * 使用资源转换技术，将独占资源变为共享资源
      * 破坏“请求和保持条”条件
         * 方案1：每个进程在运行前必须一次性的申请它所要求的全部资源，且仅当该进程所要的资源均可满足时才一次性的分配。
         * 资源利用率低，“饥饿”现象
         * 方案2：在允许进程动态申请资源的前提下规定，一个进行在申请新资源，且不能立即得到满足，必须释放已占有的全部资源。若需要再重新申请
      * 破坏“不可抢占”条件
         * 可以通过操作系统抢占这一资源（根据进程的不同优先级）
         * 局限性：适用于状态易于保存和恢复的资源，如CPU(抢占式的调度算法)，内存(页面置换算法)
      * 破坏“循环等待”条件
         * 通过定义资源类型的线性顺序实现
         * 方案：资源有序分配法。（如哲学家就餐问题）也就是把资源中所有的资源编号，进程在申请资源时，必须严格按照资源编号的递增次序进行，否则操作系统不予分配。（资源使用的频繁性？）
      * 银行家算法 request < available && request < needing;
         * 如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配
         * 银行家算法在避免死锁角度上非常有效，但是需要在进程运行前就知道其所需资源的最大值
2. 互斥同步锁（悲观锁）
* 悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
* 实现方式
	* 悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）

	哪些劣势：
		1. 阻塞，唤醒，性能低
		2. 永久阻塞
		3. 优先级，阻塞的优先级越高，持有锁的优先级越低，导致优先级反转问题
3. 非互斥同步锁（乐观锁）
* 乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断* 实现方式
   * 乐观锁的实现方式主要有两种：CAS机制和版本号机制
      * CAS 3个操作数: 需要读写的内存位置(V) 进行比较的预期值(A) 拟写入的新值(B)
      * 如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
      * CAS是由CPU支持的原子操作
      * Java中的自增操作(i++) AtomicInteger
   * CAS有哪些缺点
      * ABA问题 （线程1读取内存中数据为A；(2)线程2将该数据修改为B；(3)线程2将该数据修改为A；(4)线程1对数据进行CAS操作，在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。）带来栈顶问题，解决方法加入版本号
     * 在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。


      * CAS只能保证单个变量操作的原子性，当涉及到多个变量时
   *乐观锁加锁吗？
      * 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子
      * 有时乐观锁可能与加锁操作合作，MySQL在执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。
4. 如何选择悲观锁和乐观锁
* 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
* 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。
5. 锁粗化
* 锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。以此来减少在锁操作上的开销。
6. 自旋锁
* 所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。这里等待的方式就是执行一段无意义的循环。
7. 适应性自旋锁
* 适应性自旋锁是一种更加聪明的自旋锁。某个线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。