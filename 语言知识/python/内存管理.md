1).对象的引用计数机制

# Python是如何进行内存管理的

1. Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。

   引用计数增加的情况：

   * 一个对象分配一个新名称

   * 将其放入一个容器中（如列表、元组或字典）

   引用计数减少的情况：

   * 使用del语句对对象别名显示的销毁

   * 引用超出作用域或被重新赋值

2. 垃圾回收

   ```
   1. 引用计数
   引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当Python 的某
   个对象的引用计数降为0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如
   某个新建对象，它被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，
   那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了
   2. 标记清除
   如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被
   回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引用计数为0。所以先将循环引
   用摘掉，就会得出这两个对象的有效计数。
   3. 分代回收
   从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与系统
   中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多，而垃圾
   回收带来的额外操作就越少；反之，当需回收的内存块越少时，垃圾检测就将比垃圾回收带来更少的额
   外操作。
   ```

3. 内存池机制

* Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统:

* Pymalloc机制：为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。

* 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。