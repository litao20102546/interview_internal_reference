1. 死锁
2. 互斥同步锁（悲观锁）
* 悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
* 实现方式
	* 悲观锁的实现方式是加锁，加锁既可以是对代码块加锁（如Java的synchronized关键字），也可以是对数据加锁（如MySQL中的排它锁）

	哪些劣势：
		1. 阻塞，唤醒，性能低
		2. 永久阻塞
		3. 优先级，阻塞的优先级越高，持有锁的优先级越低，导致优先级反转问题
3. 非互斥同步锁（乐观锁）
* 乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断* 实现方式
   * 乐观锁的实现方式主要有两种：CAS机制和版本号机制
      * CAS 3个操作数: 需要读写的内存位置(V) 进行比较的预期值(A) 拟写入的新值(B)
      * 如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
      * CAS是由CPU支持的原子操作
      * Java中的自增操作(i++) AtomicInteger
   * CAS有哪些缺点
      * ABA问题 （线程1读取内存中数据为A；(2)线程2将该数据修改为B；(3)线程2将该数据修改为A；(4)线程1对数据进行CAS操作，在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。）带来栈顶问题，解决方法加入版本号
     * 在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。


      * CAS只能保证单个变量操作的原子性，当涉及到多个变量时
   *乐观锁加锁吗？
      * 乐观锁本身是不加锁的，只是在更新时判断一下数据是否被其他线程更新了；AtomicInteger便是一个例子
      * 有时乐观锁可能与加锁操作合作，MySQL在执行update时会加排它锁。但这只是乐观锁与加锁操作合作的例子，不能改变“乐观锁本身不加锁”这一事实。
4. 如何选择悲观锁和乐观锁
* 当竞争不激烈 (出现并发冲突的概率小)时，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源。
* 当竞争激烈(出现并发冲突的概率大)时，悲观锁更有优势，因为乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源。
5. 锁粗化
* 锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。以此来减少在锁操作上的开销。
6. 自旋锁
* 所谓自旋锁，就是让某线程进入已被其它线程占用的同步代码时等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。这里等待的方式就是执行一段无意义的循环。
7. 适应性自旋锁
* 适应性自旋锁是一种更加聪明的自旋锁。某个线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。